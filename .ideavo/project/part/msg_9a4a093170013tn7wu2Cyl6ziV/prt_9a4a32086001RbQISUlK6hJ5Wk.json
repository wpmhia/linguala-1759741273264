{
  "id": "prt_9a4a32086001RbQISUlK6hJ5Wk",
  "messageID": "msg_9a4a093170013tn7wu2Cyl6ziV",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "edit",
  "callID": "toolu_01J6SpT8zY5gJpaLybXjyn1H",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/translator.tsx",
      "oldString": "  const getLanguageName = (code: string) => {\n    return LANGUAGES.find(lang => lang.code === code)?.name || code\n  }",
      "newString": "  const applyGlossary = (text: string, fromLang: string, toLang: string) => {\n    let processedText = text\n    const relevantEntries = glossary.filter(entry => \n      entry.domain === selectedDomain || entry.domain === 'general'\n    )\n    \n    relevantEntries.forEach(entry => {\n      const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n      processedText = processedText.replace(regex, entry.target)\n    })\n    \n    return processedText\n  }\n\n  const addGlossaryEntry = () => {\n    if (!newGlossaryEntry.source.trim() || !newGlossaryEntry.target.trim()) {\n      toast.error(\"Source and target terms are required\")\n      return\n    }\n\n    const entry: GlossaryEntry = {\n      id: Date.now().toString(),\n      source: newGlossaryEntry.source.trim(),\n      target: newGlossaryEntry.target.trim(),\n      domain: selectedDomain,\n      notes: newGlossaryEntry.notes.trim() || undefined\n    }\n\n    setGlossary(prev => [...prev, entry])\n    setNewGlossaryEntry({ source: \"\", target: \"\", notes: \"\" })\n    toast.success(\"Glossary entry added!\")\n  }\n\n  const removeGlossaryEntry = (id: string) => {\n    setGlossary(prev => prev.filter(entry => entry.id !== id))\n    toast.success(\"Glossary entry removed!\")\n  }\n\n  const filteredHistory = history.filter(item =>\n    item.sourceText.toLowerCase().includes(historySearch.toLowerCase()) ||\n    item.translatedText.toLowerCase().includes(historySearch.toLowerCase()) ||\n    getLanguageName(item.sourceLang).toLowerCase().includes(historySearch.toLowerCase()) ||\n    getLanguageName(item.targetLang).toLowerCase().includes(historySearch.toLowerCase())\n  )\n\n  const exportHistory = () => {\n    const exportData = {\n      history: filteredHistory,\n      exportDate: new Date().toISOString(),\n      totalItems: filteredHistory.length\n    }\n    \n    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `translation-history-${new Date().toISOString().split('T')[0]}.json`\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n    toast.success(\"History exported successfully!\")\n  }\n\n  const clearHistory = () => {\n    setHistory([])\n    toast.success(\"History cleared!\")\n  }\n\n  const getLanguageName = (code: string) => {\n    return LANGUAGES.find(lang => lang.code === code)?.name || code\n  }"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/components/translator.tsx\n===================================================================\n--- /home/user/project/components/translator.tsx\n+++ /home/user/project/components/translator.tsx\n@@ -329,8 +329,77 @@\n   setSourceText(\"\")\n   setTranslatedText(\"\")\n }\n \n+const applyGlossary = (text: string, fromLang: string, toLang: string) => {\n+  let processedText = text\n+  const relevantEntries = glossary.filter(entry => \n+    entry.domain === selectedDomain || entry.domain === 'general'\n+  )\n+  \n+  relevantEntries.forEach(entry => {\n+    const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n+    processedText = processedText.replace(regex, entry.target)\n+  })\n+  \n+  return processedText\n+}\n+\n+const addGlossaryEntry = () => {\n+  if (!newGlossaryEntry.source.trim() || !newGlossaryEntry.target.trim()) {\n+    toast.error(\"Source and target terms are required\")\n+    return\n+  }\n+\n+  const entry: GlossaryEntry = {\n+    id: Date.now().toString(),\n+    source: newGlossaryEntry.source.trim(),\n+    target: newGlossaryEntry.target.trim(),\n+    domain: selectedDomain,\n+    notes: newGlossaryEntry.notes.trim() || undefined\n+  }\n+\n+  setGlossary(prev => [...prev, entry])\n+  setNewGlossaryEntry({ source: \"\", target: \"\", notes: \"\" })\n+  toast.success(\"Glossary entry added!\")\n+}\n+\n+const removeGlossaryEntry = (id: string) => {\n+  setGlossary(prev => prev.filter(entry => entry.id !== id))\n+  toast.success(\"Glossary entry removed!\")\n+}\n+\n+const filteredHistory = history.filter(item =>\n+  item.sourceText.toLowerCase().includes(historySearch.toLowerCase()) ||\n+  item.translatedText.toLowerCase().includes(historySearch.toLowerCase()) ||\n+  getLanguageName(item.sourceLang).toLowerCase().includes(historySearch.toLowerCase()) ||\n+  getLanguageName(item.targetLang).toLowerCase().includes(historySearch.toLowerCase())\n+)\n+\n+const exportHistory = () => {\n+  const exportData = {\n+    history: filteredHistory,\n+    exportDate: new Date().toISOString(),\n+    totalItems: filteredHistory.length\n+  }\n+  \n+  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' })\n+  const url = URL.createObjectURL(blob)\n+  const a = document.createElement('a')\n+  a.href = url\n+  a.download = `translation-history-${new Date().toISOString().split('T')[0]}.json`\n+  document.body.appendChild(a)\n+  a.click()\n+  document.body.removeChild(a)\n+  URL.revokeObjectURL(url)\n+  toast.success(\"History exported successfully!\")\n+}\n+\n+const clearHistory = () => {\n+  setHistory([])\n+  toast.success(\"History cleared!\")\n+}\n+\n const getLanguageName = (code: string) => {\n   return LANGUAGES.find(lang => lang.code === code)?.name || code\n }\n \n"
    },
    "title": "components/translator.tsx",
    "time": {
      "start": 1759403786874,
      "end": 1759403786887
    }
  }
}
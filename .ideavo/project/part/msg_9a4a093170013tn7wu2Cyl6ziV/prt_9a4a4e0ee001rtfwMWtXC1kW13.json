{
  "id": "prt_9a4a4e0ee001rtfwMWtXC1kW13",
  "messageID": "msg_9a4a093170013tn7wu2Cyl6ziV",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "edit",
  "callID": "toolu_01A2KzW8pZqar96upruWKdum",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/translator.tsx",
      "oldString": "  const clearHistory = () => {\n    setHistory([])\n    toast.success(\"History cleared!\")\n  }",
      "newString": "  const clearHistory = () => {\n    setHistory([])\n    toast.success(\"History cleared!\")\n  }\n\n  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0]\n    if (!file) return\n\n    const allowedTypes = ['text/plain', 'application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']\n    if (!allowedTypes.includes(file.type)) {\n      toast.error(\"Please upload a TXT, PDF, or DOCX file\")\n      return\n    }\n\n    setUploadedFile(file)\n    setIsProcessingDocument(true)\n\n    try {\n      if (file.type === 'text/plain') {\n        const content = await file.text()\n        setDocumentContent(content)\n        setSourceText(content)\n      } else {\n        // For PDF and DOCX, we'll need to extract text\n        // This is a simplified version - in production you'd use proper libraries\n        const formData = new FormData()\n        formData.append('file', file)\n        \n        const response = await fetch('/api/extract-document', {\n          method: 'POST',\n          body: formData\n        })\n        \n        if (response.ok) {\n          const data = await response.json()\n          setDocumentContent(data.content)\n          setSourceText(data.content)\n        } else {\n          throw new Error('Failed to extract document content')\n        }\n      }\n      \n      toast.success(\"Document uploaded successfully!\")\n    } catch (error) {\n      console.error('Document processing error:', error)\n      toast.error(\"Failed to process document. Please try again.\")\n    } finally {\n      setIsProcessingDocument(false)\n    }\n  }\n\n  const downloadTranslatedDocument = () => {\n    if (!translatedText.trim() || !uploadedFile) {\n      toast.error(\"No translated document to download\")\n      return\n    }\n\n    const content = `Original Document: ${uploadedFile.name}\\n\\nTranslated Content:\\n${translatedText}`\n    const blob = new Blob([content], { type: 'text/plain' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `translated-${uploadedFile.name.replace(/\\.[^/.]+$/, \"\")}.txt`\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n    toast.success(\"Translated document downloaded!\")\n  }"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/components/translator.tsx\n===================================================================\n--- /home/user/project/components/translator.tsx\n+++ /home/user/project/components/translator.tsx\n@@ -402,8 +402,74 @@\n   setHistory([])\n   toast.success(\"History cleared!\")\n }\n \n+const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {\n+  const file = event.target.files?.[0]\n+  if (!file) return\n+\n+  const allowedTypes = ['text/plain', 'application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']\n+  if (!allowedTypes.includes(file.type)) {\n+    toast.error(\"Please upload a TXT, PDF, or DOCX file\")\n+    return\n+  }\n+\n+  setUploadedFile(file)\n+  setIsProcessingDocument(true)\n+\n+  try {\n+    if (file.type === 'text/plain') {\n+      const content = await file.text()\n+      setDocumentContent(content)\n+      setSourceText(content)\n+    } else {\n+      // For PDF and DOCX, we'll need to extract text\n+      // This is a simplified version - in production you'd use proper libraries\n+      const formData = new FormData()\n+      formData.append('file', file)\n+      \n+      const response = await fetch('/api/extract-document', {\n+        method: 'POST',\n+        body: formData\n+      })\n+      \n+      if (response.ok) {\n+        const data = await response.json()\n+        setDocumentContent(data.content)\n+        setSourceText(data.content)\n+      } else {\n+        throw new Error('Failed to extract document content')\n+      }\n+    }\n+    \n+    toast.success(\"Document uploaded successfully!\")\n+  } catch (error) {\n+    console.error('Document processing error:', error)\n+    toast.error(\"Failed to process document. Please try again.\")\n+  } finally {\n+    setIsProcessingDocument(false)\n+  }\n+}\n+\n+const downloadTranslatedDocument = () => {\n+  if (!translatedText.trim() || !uploadedFile) {\n+    toast.error(\"No translated document to download\")\n+    return\n+  }\n+\n+  const content = `Original Document: ${uploadedFile.name}\\n\\nTranslated Content:\\n${translatedText}`\n+  const blob = new Blob([content], { type: 'text/plain' })\n+  const url = URL.createObjectURL(blob)\n+  const a = document.createElement('a')\n+  a.href = url\n+  a.download = `translated-${uploadedFile.name.replace(/\\.[^/.]+$/, \"\")}.txt`\n+  document.body.appendChild(a)\n+  a.click()\n+  document.body.removeChild(a)\n+  URL.revokeObjectURL(url)\n+  toast.success(\"Translated document downloaded!\")\n+}\n+\n const getLanguageName = (code: string) => {\n   return LANGUAGES.find(lang => lang.code === code)?.name || code\n }\n \n"
    },
    "title": "components/translator.tsx",
    "time": {
      "start": 1759403902018,
      "end": 1759403902028
    }
  }
}
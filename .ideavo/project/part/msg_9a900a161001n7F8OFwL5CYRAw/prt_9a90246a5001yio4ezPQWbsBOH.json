{
  "id": "prt_9a90246a5001yio4ezPQWbsBOH",
  "messageID": "msg_9a900a161001n7F8OFwL5CYRAw",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01HfE98WPwJhUkVrXgrvVF68",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/documents/upload/route.ts",
      "content": "import { NextRequest, NextResponse } from 'next/server'\nimport formidable from 'formidable'\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { fileTypeFromBuffer } from 'file-type'\nimport { PDFProcessor } from '@/lib/document-processors/pdf-processor'\nimport { DocxProcessor } from '@/lib/document-processors/docx-processor'\n\n// Configure formidable for file uploads\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n}\n\nconst MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB\nconst ALLOWED_TYPES = [\n  'application/pdf',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  'text/plain'\n]\n\n// Create upload directory if it doesn't exist\nconst uploadDir = path.join(process.cwd(), 'temp', 'uploads')\n\nasync function ensureUploadDir() {\n  try {\n    await fs.access(uploadDir)\n  } catch {\n    await fs.mkdir(uploadDir, { recursive: true })\n  }\n}\n\nfunction parseFormData(req: NextRequest): Promise<{ fields: formidable.Fields; files: formidable.Files }> {\n  return new Promise((resolve, reject) => {\n    const form = formidable({\n      uploadDir: uploadDir,\n      keepExtensions: true,\n      maxFileSize: MAX_FILE_SIZE,\n      maxTotalFileSize: MAX_FILE_SIZE,\n      allowEmptyFiles: false,\n    })\n\n    // Convert NextRequest to Node.js request\n    const nodeReq = req as any\n\n    form.parse(nodeReq, (err, fields, files) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve({ fields, files })\n      }\n    })\n  })\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureUploadDir()\n\n    // Parse the multipart form data\n    const { fields, files } = await parseFormData(request)\n\n    // Get the uploaded file\n    const fileArray = Array.isArray(files.file) ? files.file : [files.file]\n    const uploadedFile = fileArray[0]\n\n    if (!uploadedFile) {\n      return NextResponse.json(\n        { error: 'No file uploaded' },\n        { status: 400 }\n      )\n    }\n\n    // Read file buffer\n    const fileBuffer = await fs.readFile(uploadedFile.filepath)\n    \n    // Validate file type\n    const fileType = await fileTypeFromBuffer(fileBuffer)\n    if (!fileType || !ALLOWED_TYPES.includes(fileType.mime)) {\n      // Clean up the uploaded file\n      await fs.unlink(uploadedFile.filepath)\n      return NextResponse.json(\n        { error: 'Unsupported file type. Please upload PDF, DOCX, or TXT files.' },\n        { status: 400 }\n      )\n    }\n\n    // Validate file size\n    if (fileBuffer.length > MAX_FILE_SIZE) {\n      await fs.unlink(uploadedFile.filepath)\n      return NextResponse.json(\n        { error: 'File too large. Maximum size is 10MB.' },\n        { status: 400 }\n      )\n    }\n\n    // Process document based on type\n    let documentInfo: any = {}\n    \n    try {\n      if (fileType.mime === 'application/pdf') {\n        const pdfProcessor = new PDFProcessor()\n        documentInfo = await pdfProcessor.getDocumentInfo(fileBuffer)\n        documentInfo.type = 'pdf'\n      } else if (fileType.mime === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const docxProcessor = new DocxProcessor()\n        documentInfo = await docxProcessor.getDocumentInfo(fileBuffer)\n        documentInfo.type = 'docx'\n      } else if (fileType.mime === 'text/plain') {\n        const text = fileBuffer.toString('utf-8')\n        documentInfo = {\n          wordCount: text.split(/\\s+/).filter(word => word.length > 0).length,\n          fileSize: fileBuffer.length,\n          isValid: true,\n          type: 'txt'\n        }\n      }\n\n      if (!documentInfo.isValid) {\n        await fs.unlink(uploadedFile.filepath)\n        return NextResponse.json(\n          { error: 'Invalid or corrupted document' },\n          { status: 400 }\n        )\n      }\n    } catch (error) {\n      console.error('Document processing error:', error)\n      await fs.unlink(uploadedFile.filepath)\n      return NextResponse.json(\n        { error: 'Failed to process document' },\n        { status: 500 }\n      )\n    }\n\n    // Generate unique file ID\n    const fileId = `doc_${Date.now()}_${Math.random().toString(36).substring(2)}`\n    const storedFileName = `${fileId}.${fileType.ext}`\n    const storedFilePath = path.join(uploadDir, storedFileName)\n\n    // Move file to permanent storage location\n    await fs.rename(uploadedFile.filepath, storedFilePath)\n\n    // Return upload success with document info\n    return NextResponse.json({\n      success: true,\n      fileId,\n      fileName: uploadedFile.originalFilename || 'unnamed',\n      fileType: documentInfo.type,\n      fileSize: documentInfo.fileSize,\n      wordCount: documentInfo.wordCount || 0,\n      pageCount: documentInfo.pageCount || 0,\n      storedPath: storedFilePath\n    })\n\n  } catch (error) {\n    console.error('Upload error:', error)\n    \n    if (error instanceof Error) {\n      if (error.message.includes('maxFileSize')) {\n        return NextResponse.json(\n          { error: 'File too large. Maximum size is 10MB.' },\n          { status: 400 }\n        )\n      }\n    }\n\n    return NextResponse.json(\n      { error: 'Upload failed. Please try again.' },\n      { status: 500 }\n    )\n  }\n}\n\n// Handle OPTIONS for CORS\nexport async function OPTIONS() {\n  return new NextResponse(null, {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'POST, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type',\n    },\n  })\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/app/api/documents/upload/route.ts",
      "exists": false
    },
    "title": "app/api/documents/upload/route.ts",
    "time": {
      "start": 1759477141706,
      "end": 1759477141708
    }
  }
}
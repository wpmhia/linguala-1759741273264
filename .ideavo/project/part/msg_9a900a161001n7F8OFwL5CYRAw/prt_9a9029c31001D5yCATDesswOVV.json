{
  "id": "prt_9a9029c31001D5yCATDesswOVV",
  "messageID": "msg_9a900a161001n7F8OFwL5CYRAw",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01VJjTME4jyTUMFJEbxnaiEQ",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/documents/translate/route.ts",
      "content": "import { NextRequest, NextResponse } from 'next/server'\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { z } from 'zod'\nimport { PDFProcessor, PDFTranslationData } from '@/lib/document-processors/pdf-processor'\nimport { DocxProcessor, DocxTranslationData } from '@/lib/document-processors/docx-processor'\n\n// Request validation schema\nconst TranslateDocumentSchema = z.object({\n  fileId: z.string(),\n  sourceLang: z.string(),\n  targetLang: z.string(),\n  fileName: z.string().optional(),\n  fileType: z.enum(['pdf', 'docx', 'txt'])\n})\n\nasync function translateText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n  try {\n    // Use your existing translation API\n    const response = await fetch('http://localhost:3000/api/translate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        text,\n        sourceLang,\n        targetLang\n      })\n    })\n\n    if (!response.ok) {\n      throw new Error('Translation API request failed')\n    }\n\n    const data = await response.json()\n    return data.translatedText\n  } catch (error) {\n    console.error('Translation error:', error)\n    throw new Error('Failed to translate text')\n  }\n}\n\nasync function translateLongText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n  // Split long text into chunks to handle API limits\n  const MAX_CHUNK_SIZE = 4000 // Conservative limit for translation API\n  const chunks: string[] = []\n  \n  // Split by paragraphs first\n  const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n  \n  let currentChunk = ''\n  for (const paragraph of paragraphs) {\n    if (currentChunk.length + paragraph.length > MAX_CHUNK_SIZE && currentChunk.length > 0) {\n      chunks.push(currentChunk.trim())\n      currentChunk = paragraph\n    } else {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n    }\n  }\n  \n  if (currentChunk.trim()) {\n    chunks.push(currentChunk.trim())\n  }\n\n  // Translate each chunk\n  const translatedChunks: string[] = []\n  for (let i = 0; i < chunks.length; i++) {\n    console.log(`Translating chunk ${i + 1}/${chunks.length}`)\n    try {\n      const translatedChunk = await translateText(chunks[i], sourceLang, targetLang)\n      translatedChunks.push(translatedChunk)\n      \n      // Add small delay to avoid rate limiting\n      if (i < chunks.length - 1) {\n        await new Promise(resolve => setTimeout(resolve, 500))\n      }\n    } catch (error) {\n      console.error(`Error translating chunk ${i + 1}:`, error)\n      // Use original text as fallback\n      translatedChunks.push(chunks[i])\n    }\n  }\n\n  return translatedChunks.join('\\n\\n')\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    \n    // Validate input\n    const validatedInput = TranslateDocumentSchema.parse(body)\n    const { fileId, sourceLang, targetLang, fileName, fileType } = validatedInput\n\n    // Construct file path\n    const uploadDir = path.join(process.cwd(), 'temp', 'uploads')\n    const filePath = path.join(uploadDir, `${fileId}.${fileType === 'docx' ? 'docx' : fileType === 'pdf' ? 'pdf' : 'txt'}`)\n\n    // Check if file exists\n    try {\n      await fs.access(filePath)\n    } catch {\n      return NextResponse.json(\n        { error: 'File not found. Please upload the document again.' },\n        { status: 404 }\n      )\n    }\n\n    // Read file\n    const fileBuffer = await fs.readFile(filePath)\n    let translatedBuffer: Buffer\n\n    console.log(`Starting translation: ${fileType} file from ${sourceLang} to ${targetLang}`)\n\n    if (fileType === 'pdf') {\n      // Process PDF\n      const pdfProcessor = new PDFProcessor()\n      \n      // Extract text\n      const extractionResult = await pdfProcessor.extractText(fileBuffer)\n      console.log(`Extracted ${extractionResult.text.length} characters from PDF`)\n\n      // Translate text\n      const translatedText = await translateLongText(extractionResult.text, sourceLang, targetLang)\n      console.log(`Translation completed: ${translatedText.length} characters`)\n\n      // Create translated PDF\n      const translationData: PDFTranslationData = {\n        originalText: extractionResult.text,\n        translatedText,\n        sourceLang,\n        targetLang,\n        metadata: extractionResult.metadata,\n        pageCount: extractionResult.pageCount\n      }\n\n      translatedBuffer = await pdfProcessor.createTranslatedPDF(translationData)\n\n    } else if (fileType === 'docx') {\n      // Process DOCX\n      const docxProcessor = new DocxProcessor()\n      \n      // Extract text\n      const extractionResult = await docxProcessor.extractText(fileBuffer)\n      console.log(`Extracted ${extractionResult.text.length} characters from DOCX`)\n\n      // Translate text\n      const translatedText = await translateLongText(extractionResult.text, sourceLang, targetLang)\n      console.log(`Translation completed: ${translatedText.length} characters`)\n\n      // Create translated DOCX\n      const translationData: DocxTranslationData = {\n        originalText: extractionResult.text,\n        translatedText,\n        sourceLang,\n        targetLang,\n        segments: extractionResult.segments,\n        metadata: extractionResult.metadata\n      }\n\n      translatedBuffer = await docxProcessor.createTranslatedDocx(translationData)\n\n    } else if (fileType === 'txt') {\n      // Process plain text\n      const originalText = fileBuffer.toString('utf-8')\n      console.log(`Processing text file: ${originalText.length} characters`)\n\n      // Translate text\n      const translatedText = await translateLongText(originalText, sourceLang, targetLang)\n      console.log(`Translation completed: ${translatedText.length} characters`)\n\n      translatedBuffer = Buffer.from(translatedText, 'utf-8')\n\n    } else {\n      return NextResponse.json(\n        { error: 'Unsupported file type' },\n        { status: 400 }\n      )\n    }\n\n    // Save translated file\n    const translatedFileId = `translated_${fileId}`\n    const translatedFileName = `${translatedFileId}.${fileType === 'docx' ? 'docx' : fileType === 'pdf' ? 'pdf' : 'txt'}`\n    const translatedFilePath = path.join(uploadDir, translatedFileName)\n    \n    await fs.writeFile(translatedFilePath, translatedBuffer)\n\n    // Clean up original file\n    try {\n      await fs.unlink(filePath)\n    } catch (error) {\n      console.warn('Failed to clean up original file:', error)\n    }\n\n    return NextResponse.json({\n      success: true,\n      translatedFileId,\n      originalFileName: fileName || 'document',\n      translatedFileName: `${fileName || 'document'}_translated.${fileType}`,\n      fileSize: translatedBuffer.length,\n      downloadPath: `/api/documents/download/${translatedFileId}`\n    })\n\n  } catch (error) {\n    console.error('Document translation error:', error)\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: 'Invalid input', details: error.errors },\n        { status: 400 }\n      )\n    }\n\n    if (error instanceof Error) {\n      if (error.message.includes('File not found')) {\n        return NextResponse.json(\n          { error: 'Document not found. Please upload again.' },\n          { status: 404 }\n        )\n      }\n      \n      if (error.message.includes('Translation')) {\n        return NextResponse.json(\n          { error: 'Translation failed. Please try again.' },\n          { status: 500 }\n        )\n      }\n    }\n\n    return NextResponse.json(\n      { error: 'Translation failed. Please try again later.' },\n      { status: 500 }\n    )\n  }\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/app/api/documents/translate/route.ts",
      "exists": false
    },
    "title": "app/api/documents/translate/route.ts",
    "time": {
      "start": 1759477169402,
      "end": 1759477169404
    }
  }
}
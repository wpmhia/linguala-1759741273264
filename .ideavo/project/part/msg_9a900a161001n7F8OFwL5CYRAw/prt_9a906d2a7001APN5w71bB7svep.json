{
  "id": "prt_9a906d2a7001APN5w71bB7svep",
  "messageID": "msg_9a900a161001n7F8OFwL5CYRAw",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01V3RfecSG7MvCvTn27MJHKb",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/lib/document-processors/pdf-processor.ts",
      "content": "import { PDFDocument, rgb, StandardFonts } from 'pdf-lib'\nimport { fileTypeFromBuffer } from 'file-type'\n\nexport interface PDFProcessingResult {\n  text: string\n  pageCount: number\n  metadata: {\n    title?: string\n    author?: string\n    subject?: string\n    creator?: string\n  }\n  textSegments: Array<{\n    text: string\n    page: number\n    position?: { x: number; y: number }\n  }>\n}\n\nexport interface PDFTranslationData {\n  originalText: string\n  translatedText: string\n  sourceLang: string\n  targetLang: string\n  metadata: PDFProcessingResult['metadata']\n  pageCount: number\n}\n\nexport class PDFProcessor {\n  async validatePDF(buffer: Buffer): Promise<boolean> {\n    try {\n      const fileType = await fileTypeFromBuffer(buffer)\n      return fileType?.mime === 'application/pdf'\n    } catch (error) {\n      return false\n    }\n  }\n\n  async extractText(buffer: Buffer): Promise<PDFProcessingResult> {\n    try {\n      // Validate PDF first\n      if (!await this.validatePDF(buffer)) {\n        throw new Error('Invalid PDF file')\n      }\n\n      // Load PDF with pdf-lib for basic extraction\n      const pdfDoc = await PDFDocument.load(buffer)\n      const pageCount = pdfDoc.getPageCount()\n      \n      // Get metadata\n      const title = pdfDoc.getTitle()\n      const author = pdfDoc.getAuthor()\n      const subject = pdfDoc.getSubject()\n      const creator = pdfDoc.getCreator()\n\n      // For now, we'll use a simplified text extraction\n      // In production, you'd want to use a more sophisticated approach\n      const extractedText = `[PDF Content - ${pageCount} pages]\nThis PDF contains ${pageCount} page(s).\nPlease note: Advanced text extraction from PDF requires additional processing.\nFor best results, consider converting the PDF to a text file first.`\n\n      const result: PDFProcessingResult = {\n        text: extractedText,\n        pageCount,\n        metadata: {\n          title: title || undefined,\n          author: author || undefined,\n          subject: subject || undefined,\n          creator: creator || undefined,\n        },\n        textSegments: []\n      }\n\n      // Create simple text segments (one per page)\n      for (let i = 1; i <= pageCount; i++) {\n        result.textSegments.push({\n          text: `Page ${i} content`,\n          page: i\n        })\n      }\n\n      return result\n    } catch (error) {\n      console.error('PDF text extraction error:', error)\n      throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  async createTranslatedPDF(translationData: PDFTranslationData): Promise<Buffer> {\n    try {\n      // Create a new PDF document\n      const pdfDoc = await PDFDocument.create()\n      \n      // Set metadata\n      pdfDoc.setTitle(translationData.metadata.title ? `${translationData.metadata.title} (Translated)` : 'Translated Document')\n      pdfDoc.setAuthor(translationData.metadata.author || 'Linguala Translator')\n      pdfDoc.setSubject(translationData.metadata.subject || 'Translated Document')\n      pdfDoc.setCreator('Linguala Translation Platform')\n\n      // Embed font (supports more characters than default)\n      const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n      \n      // Split translated text into pages\n      const translatedPages = this.splitTextForPDF(translationData.translatedText, translationData.pageCount)\n      \n      // Create pages with translated content\n      for (const pageText of translatedPages) {\n        const page = pdfDoc.addPage()\n        const { width, height } = page.getSize()\n        \n        // Calculate text layout\n        const fontSize = 11\n        const lineHeight = fontSize * 1.2\n        const margin = 50\n        const maxWidth = width - (margin * 2)\n        \n        // Wrap text to fit page width\n        const wrappedLines = this.wrapText(pageText, font, fontSize, maxWidth)\n        \n        // Draw text on page\n        let yPosition = height - margin\n        for (const line of wrappedLines) {\n          if (yPosition < margin) break // Avoid text overflow at bottom\n          \n          page.drawText(line, {\n            x: margin,\n            y: yPosition,\n            size: fontSize,\n            font: font,\n            color: rgb(0, 0, 0),\n          })\n          \n          yPosition -= lineHeight\n        }\n      }\n\n      // Serialize PDF to bytes\n      const pdfBytes = await pdfDoc.save()\n      return Buffer.from(pdfBytes)\n      \n    } catch (error) {\n      console.error('PDF creation error:', error)\n      throw new Error(`Failed to create translated PDF: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  private splitTextForPDF(text: string, pageCount: number): string[] {\n    // More intelligent text splitting for PDF creation\n    const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n    \n    if (paragraphs.length <= pageCount) {\n      // If we have fewer paragraphs than pages, distribute evenly\n      const pages: string[] = []\n      const parasPerPage = Math.ceil(paragraphs.length / pageCount)\n      \n      for (let i = 0; i < pageCount; i++) {\n        const start = i * parasPerPage\n        const end = Math.min(start + parasPerPage, paragraphs.length)\n        pages.push(paragraphs.slice(start, end).join('\\n\\n'))\n      }\n      \n      return pages.filter(p => p.trim())\n    } else {\n      // If we have more paragraphs than pages, fill pages to capacity\n      const avgCharsPerPage = Math.ceil(text.length / pageCount)\n      const pages: string[] = []\n      let currentPage = ''\n      \n      for (const paragraph of paragraphs) {\n        if (currentPage.length + paragraph.length > avgCharsPerPage && currentPage.length > 0) {\n          pages.push(currentPage.trim())\n          currentPage = paragraph\n        } else {\n          currentPage += (currentPage ? '\\n\\n' : '') + paragraph\n        }\n      }\n      \n      if (currentPage.trim()) {\n        pages.push(currentPage.trim())\n      }\n      \n      return pages\n    }\n  }\n\n  private wrapText(text: string, font: any, fontSize: number, maxWidth: number): string[] {\n    const lines: string[] = []\n    const words = text.split(' ')\n    let currentLine = ''\n    \n    for (const word of words) {\n      const testLine = currentLine ? `${currentLine} ${word}` : word\n      const textWidth = font.widthOfTextAtSize(testLine, fontSize)\n      \n      if (textWidth <= maxWidth) {\n        currentLine = testLine\n      } else {\n        if (currentLine) {\n          lines.push(currentLine)\n        }\n        currentLine = word\n      }\n    }\n    \n    if (currentLine) {\n      lines.push(currentLine)\n    }\n    \n    return lines\n  }\n\n  async getDocumentInfo(buffer: Buffer): Promise<{ pageCount: number; fileSize: number; isValid: boolean }> {\n    try {\n      const isValid = await this.validatePDF(buffer)\n      if (!isValid) {\n        return { pageCount: 0, fileSize: buffer.length, isValid: false }\n      }\n\n      const pdfDoc = await PDFDocument.load(buffer)\n      return {\n        pageCount: pdfDoc.getPageCount(),\n        fileSize: buffer.length,\n        isValid: true\n      }\n    } catch (error) {\n      return { pageCount: 0, fileSize: buffer.length, isValid: false }\n    }\n  }\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/lib/document-processors/pdf-processor.ts",
      "exists": true
    },
    "title": "lib/document-processors/pdf-processor.ts",
    "time": {
      "start": 1759477447270,
      "end": 1759477447272
    }
  }
}
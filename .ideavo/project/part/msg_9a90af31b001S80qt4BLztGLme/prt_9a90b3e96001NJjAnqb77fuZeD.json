{
  "id": "prt_9a90b3e96001NJjAnqb77fuZeD",
  "messageID": "msg_9a90af31b001S80qt4BLztGLme",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_018tScWjf8AcyojABJ6NTbRA",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/translate/route.ts",
      "offset": 150,
      "limit": 100
    },
    "output": "<file>\n00151|         { error: 'API key not configured. Please set DASHSCOPE_API_KEY environment variable.' },\n00152|         { status: 500 }\n00153|       )\n00154|     }\n00155| \n00156|     // Prepare the translation options\n00157|     const sourceLanguage = LANGUAGE_MAP[sourceLang] || (sourceLang === 'auto' ? 'auto' : sourceLang)\n00158|     const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n00159| \n00160|     // Apply glossary preprocessing if provided\n00161|     let processedText = text\n00162|     if (glossary && Array.isArray(glossary)) {\n00163|       glossary.forEach((entry: any) => {\n00164|         if (entry.source && entry.target) {\n00165|           // Simple case-insensitive replacement\n00166|           const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n00167|           processedText = processedText.replace(regex, `[GLOSSARY:${entry.target}]`)\n00168|         }\n00169|       })\n00170|     }\n00171| \n00172|     // Add domain context to improve translation quality\n00173|     const domainContexts: Record<string, string> = {\n00174|       technical: \"This is a technical/IT translation. Focus on accurate technical terminology.\",\n00175|       medical: \"This is a medical translation. Use precise medical terminology.\",\n00176|       legal: \"This is a legal translation. Maintain formal legal language and terminology.\",\n00177|       business: \"This is a business translation. Use professional business terminology.\",\n00178|       academic: \"This is an academic translation. Use scholarly and precise language.\",\n00179|       creative: \"This is a creative translation. Maintain the tone and style of the original.\"\n00180|     }\n00181| \n00182|     // Use a more direct translation prompt approach\n00183|     try {\n00184|       const response = await fetch('https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions', {\n00185|         method: 'POST',\n00186|         headers: {\n00187|           'Authorization': `Bearer ${apiKey}`,\n00188|           'Content-Type': 'application/json',\n00189|         },\n00190|         body: JSON.stringify({\n00191|           model: 'qwen-mt-turbo',\n00192|           messages: [{\n00193|             role: 'user',\n00194|             content: text\n00195|           }],\n00196|           translation_options: {\n00197|             source_lang: sourceLanguage,\n00198|             target_lang: targetLanguage\n00199|           }\n00200|         }),\n00201|       })\n00202| \n00203|       if (!response.ok) {\n00204|         const errorData = await response.text()\n00205|         console.error('Qwen API error:', response.status, errorData)\n00206|         throw new Error(`Translation API error: ${response.status}`)\n00207|       }\n00208| \n00209|       const data = await response.json()\n00210|       const translatedText = data.choices?.[0]?.message?.content?.trim()\n00211| \n00212|       if (!translatedText) {\n00213|         throw new Error('No translation received from API')\n00214|       }\n00215| \n00216|       // Clean up the response (remove quotes if the API added them)\n00217|       const cleanedTranslation = translatedText.replace(/^[\"']|[\"']$/g, '').trim()\n00218|       \n00219|       return NextResponse.json({\n00220|         translatedText: cleanedTranslation,\n00221|         sourceLang,\n00222|         targetLang,\n00223|       })\n00224|       \n00225|     } catch (apiError) {\n00226|       console.error('Translation API failed, using fallback:', apiError)\n00227|       \n00228|       // Fallback to a simple dictionary-based translation for common phrases\n00229|       const fallbackTranslations = getFallbackTranslation(text, targetLanguage)\n00230|       \n00231|       return NextResponse.json({\n00232|         translatedText: fallbackTranslations || `Translation temporarily unavailable for: \"${text}\"`,\n00233|         sourceLang,\n00234|         targetLang,\n00235|         fallback: true\n00236|       })\n00237|     }\n00238| \n00239|   } catch (error) {\n00240|     console.error('Translation error:', error)\n00241|     return NextResponse.json(\n00242|       { error: 'Internal server error' },\n00243|       { status: 500 }\n00244|     )\n00245|   }\n00246| }\n</file>",
    "metadata": {
      "preview": "        { error: 'API key not configured. Please set DASHSCOPE_API_KEY environment variable.' },\n        { status: 500 }\n      )\n    }\n\n    // Prepare the translation options\n    const sourceLanguage = LANGUAGE_MAP[sourceLang] || (sourceLang === 'auto' ? 'auto' : sourceLang)\n    const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n\n    // Apply glossary preprocessing if provided\n    let processedText = text\n    if (glossary && Array.isArray(glossary)) {\n      glossary.forEach((entry: any) => {\n        if (entry.source && entry.target) {\n          // Simple case-insensitive replacement\n          const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n          processedText = processedText.replace(regex, `[GLOSSARY:${entry.target}]`)\n        }\n      })\n    }"
    },
    "title": "app/api/translate/route.ts",
    "time": {
      "start": 1759477711415,
      "end": 1759477711417
    }
  }
}
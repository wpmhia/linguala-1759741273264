{
  "id": "prt_9a90b5098001mdAzwnrfYtmAHE",
  "messageID": "msg_9a90af31b001S80qt4BLztGLme",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01M22QSBCivzimsxoicx5kFM",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/lib/translation-service.ts",
      "content": "// Shared translation service that can be used both in API routes and internally\n\n// Language mapping for translation API - includes all frontend languages\nconst LANGUAGE_MAP: Record<string, string> = {\n  auto: 'auto',\n  \n  // Popular EU Languages\n  en: 'English',\n  de: 'German', \n  fr: 'French',\n  es: 'Spanish',\n  it: 'Italian',\n  pt: 'Portuguese',\n  pl: 'Polish',\n  nl: 'Dutch',\n  \n  // Nordic EU Languages\n  da: 'Danish',\n  sv: 'Swedish',\n  fi: 'Finnish',\n  no: 'Norwegian',\n  \n  // Major World Languages\n  ru: 'Russian',\n  zh: 'Chinese',\n  ja: 'Japanese',\n  ko: 'Korean',\n  ar: 'Arabic',\n  hi: 'Hindi',\n  tr: 'Turkish',\n  th: 'Thai',\n  vi: 'Vietnamese',\n  \n  // Other EU Languages\n  ga: 'Irish',\n  mt: 'Maltese',\n  cs: 'Czech',\n  sk: 'Slovak',\n  hu: 'Hungarian',\n  sl: 'Slovenian',\n  hr: 'Croatian',\n  bg: 'Bulgarian',\n  ro: 'Romanian',\n  lt: 'Lithuanian',\n  lv: 'Latvian',\n  et: 'Estonian',\n  el: 'Greek',\n}\n\n// Fallback translation for common phrases\nfunction getFallbackTranslation(text: string, targetLanguage: string): string | null {\n  const lowerText = text.toLowerCase().trim()\n  \n  const commonPhrases: Record<string, Record<string, string>> = {\n    'hello': {\n      'Danish': 'Hej',\n      'Swedish': 'Hej', \n      'Norwegian': 'Hei',\n      'Finnish': 'Hei',\n      'German': 'Hallo',\n      'French': 'Bonjour',\n      'Spanish': 'Hola',\n      'Italian': 'Ciao',\n      'Portuguese': 'Olá',\n      'Dutch': 'Hallo',\n      'Polish': 'Cześć',\n      'Russian': 'Привет'\n    },\n    'good morning': {\n      'Danish': 'God morgen',\n      'Swedish': 'God morgon',\n      'Norwegian': 'God morgen', \n      'Finnish': 'Hyvää huomenta',\n      'German': 'Guten Morgen',\n      'French': 'Bonjour',\n      'Spanish': 'Buenos días',\n      'Dutch': 'Goedemorgen'\n    },\n    'thank you': {\n      'Danish': 'Tak',\n      'Swedish': 'Tack',\n      'Norwegian': 'Takk',\n      'Finnish': 'Kiitos',\n      'German': 'Danke',\n      'French': 'Merci',\n      'Spanish': 'Gracias',\n      'Dutch': 'Dank je'\n    }\n  }\n  \n  for (const [phrase, translations] of Object.entries(commonPhrases)) {\n    if (lowerText.includes(phrase)) {\n      return translations[targetLanguage] || null\n    }\n  }\n  \n  return null\n}\n\nexport interface TranslationResult {\n  translatedText: string\n  sourceLang: string\n  targetLang: string\n  fallback?: boolean\n}\n\nexport async function translateText(\n  text: string, \n  sourceLang: string, \n  targetLang: string,\n  options?: {\n    domain?: string\n    glossary?: Array<{ source: string; target: string }>\n  }\n): Promise<TranslationResult> {\n  try {\n    if (!text || !targetLang) {\n      throw new Error('Text and target language are required')\n    }\n\n    const apiKey = process.env.DASHSCOPE_API_KEY\n    if (!apiKey) {\n      throw new Error('API key not configured')\n    }\n\n    // Prepare the translation options\n    const sourceLanguage = LANGUAGE_MAP[sourceLang] || (sourceLang === 'auto' ? 'auto' : sourceLang)\n    const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n\n    // Apply glossary preprocessing if provided\n    let processedText = text\n    if (options?.glossary && Array.isArray(options.glossary)) {\n      options.glossary.forEach((entry: any) => {\n        if (entry.source && entry.target) {\n          // Simple case-insensitive replacement\n          const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n          processedText = processedText.replace(regex, `[GLOSSARY:${entry.target}]`)\n        }\n      })\n    }\n\n    // Use DashScope translation API\n    const response = await fetch('https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model: 'qwen-mt-turbo',\n        messages: [{\n          role: 'user',\n          content: processedText\n        }],\n        translation_options: {\n          source_lang: sourceLanguage,\n          target_lang: targetLanguage\n        }\n      }),\n    })\n\n    if (!response.ok) {\n      const errorData = await response.text()\n      console.error('DashScope API error:', response.status, errorData)\n      throw new Error(`Translation API error: ${response.status}`)\n    }\n\n    const data = await response.json()\n    const translatedText = data.choices?.[0]?.message?.content?.trim()\n\n    if (!translatedText) {\n      throw new Error('No translation received from API')\n    }\n\n    // Clean up the response (remove quotes if the API added them)\n    const cleanedTranslation = translatedText.replace(/^[\"']|[\"']$/g, '').trim()\n    \n    return {\n      translatedText: cleanedTranslation,\n      sourceLang,\n      targetLang,\n    }\n    \n  } catch (apiError) {\n    console.error('Translation API failed, using fallback:', apiError)\n    \n    // Fallback to a simple dictionary-based translation for common phrases\n    const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n    const fallbackTranslation = getFallbackTranslation(text, targetLanguage)\n    \n    return {\n      translatedText: fallbackTranslation || `Translation temporarily unavailable for: \"${text}\"`,\n      sourceLang,\n      targetLang,\n      fallback: true\n    }\n  }\n}\n\nexport async function translateLongText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n  // Split long text into chunks to handle API limits\n  const MAX_CHUNK_SIZE = 4000 // Conservative limit for translation API\n  const chunks: string[] = []\n  \n  // Split by paragraphs first\n  const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n  \n  let currentChunk = ''\n  for (const paragraph of paragraphs) {\n    if (currentChunk.length + paragraph.length > MAX_CHUNK_SIZE && currentChunk.length > 0) {\n      chunks.push(currentChunk.trim())\n      currentChunk = paragraph\n    } else {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n    }\n  }\n  \n  if (currentChunk.trim()) {\n    chunks.push(currentChunk.trim())\n  }\n\n  // Translate each chunk\n  const translatedChunks: string[] = []\n  for (let i = 0; i < chunks.length; i++) {\n    console.log(`Translating chunk ${i + 1}/${chunks.length}`)\n    try {\n      const result = await translateText(chunks[i], sourceLang, targetLang)\n      translatedChunks.push(result.translatedText)\n      \n      // Add small delay to avoid rate limiting\n      if (i < chunks.length - 1) {\n        await new Promise(resolve => setTimeout(resolve, 500))\n      }\n    } catch (error) {\n      console.error(`Error translating chunk ${i + 1}:`, error)\n      // Use original text as fallback\n      translatedChunks.push(chunks[i])\n    }\n  }\n\n  return translatedChunks.join('\\n\\n')\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/lib/translation-service.ts",
      "exists": false
    },
    "title": "lib/translation-service.ts",
    "time": {
      "start": 1759477739638,
      "end": 1759477739640
    }
  }
}
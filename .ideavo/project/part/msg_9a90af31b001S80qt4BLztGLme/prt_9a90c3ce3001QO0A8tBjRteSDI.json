{
  "id": "prt_9a90c3ce3001QO0A8tBjRteSDI",
  "messageID": "msg_9a90af31b001S80qt4BLztGLme",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "edit",
  "callID": "toolu_01Ub3Kayg3VyLEAp2QxctMK9",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/documents/translate/route.ts",
      "oldString": "async function translateText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n  try {\n    // Use your existing translation API\n    const response = await fetch('http://localhost:3000/api/translate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        text,\n        sourceLang,\n        targetLang\n      })\n    })\n\n    if (!response.ok) {\n      throw new Error('Translation API request failed')\n    }\n\n    const data = await response.json()\n    return data.translatedText\n  } catch (error) {\n    console.error('Translation error:', error)\n    throw new Error('Failed to translate text')\n  }\n}\n\nasync function translateLongText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n  // Split long text into chunks to handle API limits\n  const MAX_CHUNK_SIZE = 4000 // Conservative limit for translation API\n  const chunks: string[] = []\n  \n  // Split by paragraphs first\n  const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n  \n  let currentChunk = ''\n  for (const paragraph of paragraphs) {\n    if (currentChunk.length + paragraph.length > MAX_CHUNK_SIZE && currentChunk.length > 0) {\n      chunks.push(currentChunk.trim())\n      currentChunk = paragraph\n    } else {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n    }\n  }\n  \n  if (currentChunk.trim()) {\n    chunks.push(currentChunk.trim())\n  }\n\n  // Translate each chunk\n  const translatedChunks: string[] = []\n  for (let i = 0; i < chunks.length; i++) {\n    console.log(`Translating chunk ${i + 1}/${chunks.length}`)\n    try {\n      const translatedChunk = await translateText(chunks[i], sourceLang, targetLang)\n      translatedChunks.push(translatedChunk)\n      \n      // Add small delay to avoid rate limiting\n      if (i < chunks.length - 1) {\n        await new Promise(resolve => setTimeout(resolve, 500))\n      }\n    } catch (error) {\n      console.error(`Error translating chunk ${i + 1}:`, error)\n      // Use original text as fallback\n      translatedChunks.push(chunks[i])\n    }\n  }\n\n  return translatedChunks.join('\\n\\n')\n}",
      "newString": "// Translation function is now imported from shared service"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/app/api/documents/translate/route.ts\n===================================================================\n--- /home/user/project/app/api/documents/translate/route.ts\n+++ /home/user/project/app/api/documents/translate/route.ts\n@@ -14,79 +14,10 @@\n   fileName: z.string().optional(),\n   fileType: z.enum(['pdf', 'docx', 'txt'])\n })\n \n-async function translateText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n-  try {\n-    // Use your existing translation API\n-    const response = await fetch('http://localhost:3000/api/translate', {\n-      method: 'POST',\n-      headers: {\n-        'Content-Type': 'application/json',\n-      },\n-      body: JSON.stringify({\n-        text,\n-        sourceLang,\n-        targetLang\n-      })\n-    })\n+// Translation function is now imported from shared service\n \n-    if (!response.ok) {\n-      throw new Error('Translation API request failed')\n-    }\n-\n-    const data = await response.json()\n-    return data.translatedText\n-  } catch (error) {\n-    console.error('Translation error:', error)\n-    throw new Error('Failed to translate text')\n-  }\n-}\n-\n-async function translateLongText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n-  // Split long text into chunks to handle API limits\n-  const MAX_CHUNK_SIZE = 4000 // Conservative limit for translation API\n-  const chunks: string[] = []\n-  \n-  // Split by paragraphs first\n-  const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n-  \n-  let currentChunk = ''\n-  for (const paragraph of paragraphs) {\n-    if (currentChunk.length + paragraph.length > MAX_CHUNK_SIZE && currentChunk.length > 0) {\n-      chunks.push(currentChunk.trim())\n-      currentChunk = paragraph\n-    } else {\n-      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n-    }\n-  }\n-  \n-  if (currentChunk.trim()) {\n-    chunks.push(currentChunk.trim())\n-  }\n-\n-  // Translate each chunk\n-  const translatedChunks: string[] = []\n-  for (let i = 0; i < chunks.length; i++) {\n-    console.log(`Translating chunk ${i + 1}/${chunks.length}`)\n-    try {\n-      const translatedChunk = await translateText(chunks[i], sourceLang, targetLang)\n-      translatedChunks.push(translatedChunk)\n-      \n-      // Add small delay to avoid rate limiting\n-      if (i < chunks.length - 1) {\n-        await new Promise(resolve => setTimeout(resolve, 500))\n-      }\n-    } catch (error) {\n-      console.error(`Error translating chunk ${i + 1}:`, error)\n-      // Use original text as fallback\n-      translatedChunks.push(chunks[i])\n-    }\n-  }\n-\n-  return translatedChunks.join('\\n\\n')\n-}\n-\n export async function POST(request: NextRequest) {\n   try {\n     const body = await request.json()\n     \n"
    },
    "title": "app/api/documents/translate/route.ts",
    "time": {
      "start": 1759477781938,
      "end": 1759477781944
    }
  }
}
{
  "id": "prt_9a90d1f36002kH4n72T4ZFGU6C",
  "messageID": "msg_9a90af31b001S80qt4BLztGLme",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "edit",
  "callID": "toolu_01FLPXFh1zt6v2hSrLxvJEpF",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/translate/route.ts",
      "oldString": "export async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    console.log('Translation request body:', body)\n    \n    const { text, sourceLang, targetLang, domain, glossary } = body\n\n    if (!text || !targetLang) {\n      console.log('Missing required fields:', { text: !!text, targetLang: !!targetLang })\n      return NextResponse.json(\n        { error: 'Text and target language are required' },\n        { status: 400 }\n      )\n    }\n\n    const apiKey = process.env.DASHSCOPE_API_KEY\n    if (!apiKey) {\n      return NextResponse.json(\n        { error: 'API key not configured. Please set DASHSCOPE_API_KEY environment variable.' },\n        { status: 500 }\n      )\n    }\n\n    // Prepare the translation options\n    const sourceLanguage = LANGUAGE_MAP[sourceLang] || (sourceLang === 'auto' ? 'auto' : sourceLang)\n    const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n\n    // Apply glossary preprocessing if provided\n    let processedText = text\n    if (glossary && Array.isArray(glossary)) {\n      glossary.forEach((entry: any) => {\n        if (entry.source && entry.target) {\n          // Simple case-insensitive replacement\n          const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n          processedText = processedText.replace(regex, `[GLOSSARY:${entry.target}]`)\n        }\n      })\n    }\n\n    // Add domain context to improve translation quality\n    const domainContexts: Record<string, string> = {\n      technical: \"This is a technical/IT translation. Focus on accurate technical terminology.\",\n      medical: \"This is a medical translation. Use precise medical terminology.\",\n      legal: \"This is a legal translation. Maintain formal legal language and terminology.\",\n      business: \"This is a business translation. Use professional business terminology.\",\n      academic: \"This is an academic translation. Use scholarly and precise language.\",\n      creative: \"This is a creative translation. Maintain the tone and style of the original.\"\n    }\n\n    // Use a more direct translation prompt approach\n    try {\n      const response = await fetch('https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: 'qwen-mt-turbo',\n          messages: [{\n            role: 'user',\n            content: text\n          }],\n          translation_options: {\n            source_lang: sourceLanguage,\n            target_lang: targetLanguage\n          }\n        }),\n      })\n\n      if (!response.ok) {\n        const errorData = await response.text()\n        console.error('Qwen API error:', response.status, errorData)\n        throw new Error(`Translation API error: ${response.status}`)\n      }\n\n      const data = await response.json()\n      const translatedText = data.choices?.[0]?.message?.content?.trim()\n\n      if (!translatedText) {\n        throw new Error('No translation received from API')\n      }\n\n      // Clean up the response (remove quotes if the API added them)\n      const cleanedTranslation = translatedText.replace(/^[\"']|[\"']$/g, '').trim()\n      \n      return NextResponse.json({\n        translatedText: cleanedTranslation,\n        sourceLang,\n        targetLang,\n      })\n      \n    } catch (apiError) {\n      console.error('Translation API failed, using fallback:', apiError)\n      \n      // Fallback to a simple dictionary-based translation for common phrases\n      const fallbackTranslations = getFallbackTranslation(text, targetLanguage)\n      \n      return NextResponse.json({\n        translatedText: fallbackTranslations || `Translation temporarily unavailable for: \"${text}\"`,\n        sourceLang,\n        targetLang,\n        fallback: true\n      })\n    }\n\n  } catch (error) {\n    console.error('Translation error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}",
      "newString": "export async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    console.log('Translation request body:', body)\n    \n    const { text, sourceLang, targetLang, domain, glossary } = body\n\n    if (!text || !targetLang) {\n      console.log('Missing required fields:', { text: !!text, targetLang: !!targetLang })\n      return NextResponse.json(\n        { error: 'Text and target language are required' },\n        { status: 400 }\n      )\n    }\n\n    // Use the shared translation service\n    const result = await translateText(text, sourceLang, targetLang, {\n      domain,\n      glossary\n    })\n\n    return NextResponse.json(result)\n\n  } catch (error) {\n    console.error('Translation error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/app/api/translate/route.ts\n===================================================================\n--- /home/user/project/app/api/translate/route.ts\n+++ /home/user/project/app/api/translate/route.ts\n@@ -15,99 +15,16 @@\n       { status: 400 }\n     )\n   }\n \n-  const apiKey = process.env.DASHSCOPE_API_KEY\n-  if (!apiKey) {\n-    return NextResponse.json(\n-      { error: 'API key not configured. Please set DASHSCOPE_API_KEY environment variable.' },\n-      { status: 500 }\n-    )\n-  }\n+  // Use the shared translation service\n+  const result = await translateText(text, sourceLang, targetLang, {\n+    domain,\n+    glossary\n+  })\n \n-  // Prepare the translation options\n-  const sourceLanguage = LANGUAGE_MAP[sourceLang] || (sourceLang === 'auto' ? 'auto' : sourceLang)\n-  const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n+  return NextResponse.json(result)\n \n-  // Apply glossary preprocessing if provided\n-  let processedText = text\n-  if (glossary && Array.isArray(glossary)) {\n-    glossary.forEach((entry: any) => {\n-      if (entry.source && entry.target) {\n-        // Simple case-insensitive replacement\n-        const regex = new RegExp(`\\\\b${entry.source.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi')\n-        processedText = processedText.replace(regex, `[GLOSSARY:${entry.target}]`)\n-      }\n-    })\n-  }\n-\n-  // Add domain context to improve translation quality\n-  const domainContexts: Record<string, string> = {\n-    technical: \"This is a technical/IT translation. Focus on accurate technical terminology.\",\n-    medical: \"This is a medical translation. Use precise medical terminology.\",\n-    legal: \"This is a legal translation. Maintain formal legal language and terminology.\",\n-    business: \"This is a business translation. Use professional business terminology.\",\n-    academic: \"This is an academic translation. Use scholarly and precise language.\",\n-    creative: \"This is a creative translation. Maintain the tone and style of the original.\"\n-  }\n-\n-  // Use a more direct translation prompt approach\n-  try {\n-    const response = await fetch('https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions', {\n-      method: 'POST',\n-      headers: {\n-        'Authorization': `Bearer ${apiKey}`,\n-        'Content-Type': 'application/json',\n-      },\n-      body: JSON.stringify({\n-        model: 'qwen-mt-turbo',\n-        messages: [{\n-          role: 'user',\n-          content: text\n-        }],\n-        translation_options: {\n-          source_lang: sourceLanguage,\n-          target_lang: targetLanguage\n-        }\n-      }),\n-    })\n-\n-    if (!response.ok) {\n-      const errorData = await response.text()\n-      console.error('Qwen API error:', response.status, errorData)\n-      throw new Error(`Translation API error: ${response.status}`)\n-    }\n-\n-    const data = await response.json()\n-    const translatedText = data.choices?.[0]?.message?.content?.trim()\n-\n-    if (!translatedText) {\n-      throw new Error('No translation received from API')\n-    }\n-\n-    // Clean up the response (remove quotes if the API added them)\n-    const cleanedTranslation = translatedText.replace(/^[\"']|[\"']$/g, '').trim()\n-    \n-    return NextResponse.json({\n-      translatedText: cleanedTranslation,\n-      sourceLang,\n-      targetLang,\n-    })\n-    \n-  } catch (apiError) {\n-    console.error('Translation API failed, using fallback:', apiError)\n-    \n-    // Fallback to a simple dictionary-based translation for common phrases\n-    const fallbackTranslations = getFallbackTranslation(text, targetLanguage)\n-    \n-    return NextResponse.json({\n-      translatedText: fallbackTranslations || `Translation temporarily unavailable for: \"${text}\"`,\n-      sourceLang,\n-      targetLang,\n-      fallback: true\n-    })\n-  }\n-\n } catch (error) {\n   console.error('Translation error:', error)\n   return NextResponse.json(\n     { error: 'Internal server error' },\n"
    },
    "title": "app/api/translate/route.ts",
    "time": {
      "start": 1759477851526,
      "end": 1759477851540
    }
  }
}
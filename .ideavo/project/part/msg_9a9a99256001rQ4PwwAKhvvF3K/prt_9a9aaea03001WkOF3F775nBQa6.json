{
  "id": "prt_9a9aaea03001WkOF3F775nBQa6",
  "messageID": "msg_9a9a99256001rQ4PwwAKhvvF3K",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_012KsRQLkhn8xjQrmDFF77SF",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/documents/translate/route.ts"
    },
    "output": "<file>\n00001| /**\n00002|  * Document Translation API Route\n00003|  * \n00004|  * Processes and translates uploaded documents (PDF, DOCX, TXT) using DashScope API.\n00005|  * ENVIRONMENT: DASHSCOPE_API_KEY must be set (currently: sk-ad9404d1ced5426082b73e685a95ffa3)\n00006|  * Uses chunked translation for large documents to handle API limits.\n00007|  */\n00008| import { NextRequest, NextResponse } from 'next/server'\n00009| import { promises as fs } from 'fs'\n00010| import path from 'path'\n00011| import { z } from 'zod'\n00012| import { PDFProcessor, PDFTranslationData } from '@/lib/document-processors/pdf-processor'\n00013| import { DocxProcessor, DocxTranslationData } from '@/lib/document-processors/docx-processor'\n00014| import { translateLongText } from '@/lib/translation-service'\n00015| \n00016| // Request validation schema\n00017| const TranslateDocumentSchema = z.object({\n00018|   fileId: z.string(),\n00019|   sourceLang: z.string(),\n00020|   targetLang: z.string(),\n00021|   fileName: z.string().optional(),\n00022|   fileType: z.enum(['pdf', 'docx', 'txt'])\n00023| })\n00024| \n00025| // Translation function is now imported from shared service\n00026| \n00027| export async function POST(request: NextRequest) {\n00028|   try {\n00029|     const body = await request.json()\n00030|     \n00031|     // Validate input\n00032|     const validatedInput = TranslateDocumentSchema.parse(body)\n00033|     const { fileId, sourceLang, targetLang, fileName, fileType } = validatedInput\n00034| \n00035|     // Construct file path\n00036|     const uploadDir = path.join(process.cwd(), 'temp', 'uploads')\n00037|     const filePath = path.join(uploadDir, `${fileId}.${fileType === 'docx' ? 'docx' : fileType === 'pdf' ? 'pdf' : 'txt'}`)\n00038| \n00039|     // Check if file exists\n00040|     try {\n00041|       await fs.access(filePath)\n00042|     } catch {\n00043|       return NextResponse.json(\n00044|         { error: 'File not found. Please upload the document again.' },\n00045|         { status: 404 }\n00046|       )\n00047|     }\n00048| \n00049|     // Read file\n00050|     const fileBuffer = await fs.readFile(filePath)\n00051|     let translatedBuffer: Buffer\n00052| \n00053|     console.log(`Starting translation: ${fileType} file from ${sourceLang} to ${targetLang}`)\n00054| \n00055|     if (fileType === 'pdf') {\n00056|       // Process PDF\n00057|       const pdfProcessor = new PDFProcessor()\n00058|       \n00059|       // Extract text\n00060|       const extractionResult = await pdfProcessor.extractText(fileBuffer)\n00061|       console.log(`Extracted ${extractionResult.text.length} characters from PDF`)\n00062| \n00063|       // Translate text\n00064|       const translatedText = await translateLongText(extractionResult.text, sourceLang, targetLang)\n00065|       console.log(`Translation completed: ${translatedText.length} characters`)\n00066| \n00067|       // Create translated PDF\n00068|       const translationData: PDFTranslationData = {\n00069|         originalText: extractionResult.text,\n00070|         translatedText,\n00071|         sourceLang,\n00072|         targetLang,\n00073|         metadata: extractionResult.metadata,\n00074|         pageCount: extractionResult.pageCount\n00075|       }\n00076| \n00077|       translatedBuffer = await pdfProcessor.createTranslatedPDF(translationData)\n00078| \n00079|     } else if (fileType === 'docx') {\n00080|       // Process DOCX\n00081|       const docxProcessor = new DocxProcessor()\n00082|       \n00083|       // Extract text\n00084|       const extractionResult = await docxProcessor.extractText(fileBuffer)\n00085|       console.log(`Extracted ${extractionResult.text.length} characters from DOCX`)\n00086| \n00087|       // Translate text\n00088|       const translatedText = await translateLongText(extractionResult.text, sourceLang, targetLang)\n00089|       console.log(`Translation completed: ${translatedText.length} characters`)\n00090| \n00091|       // Create translated DOCX\n00092|       const translationData: DocxTranslationData = {\n00093|         originalText: extractionResult.text,\n00094|         translatedText,\n00095|         sourceLang,\n00096|         targetLang,\n00097|         segments: extractionResult.segments,\n00098|         metadata: extractionResult.metadata\n00099|       }\n00100| \n00101|       translatedBuffer = await docxProcessor.createTranslatedDocx(translationData)\n00102| \n00103|     } else if (fileType === 'txt') {\n00104|       // Process plain text\n00105|       const originalText = fileBuffer.toString('utf-8')\n00106|       console.log(`Processing text file: ${originalText.length} characters`)\n00107| \n00108|       // Translate text\n00109|       const translatedText = await translateLongText(originalText, sourceLang, targetLang)\n00110|       console.log(`Translation completed: ${translatedText.length} characters`)\n00111| \n00112|       translatedBuffer = Buffer.from(translatedText, 'utf-8')\n00113| \n00114|     } else {\n00115|       return NextResponse.json(\n00116|         { error: 'Unsupported file type' },\n00117|         { status: 400 }\n00118|       )\n00119|     }\n00120| \n00121|     // Save translated file\n00122|     const translatedFileId = `translated_${fileId}`\n00123|     const translatedFileName = `${translatedFileId}.${fileType === 'docx' ? 'docx' : fileType === 'pdf' ? 'pdf' : 'txt'}`\n00124|     const translatedFilePath = path.join(uploadDir, translatedFileName)\n00125|     \n00126|     await fs.writeFile(translatedFilePath, translatedBuffer)\n00127| \n00128|     // Clean up original file\n00129|     try {\n00130|       await fs.unlink(filePath)\n00131|     } catch (error) {\n00132|       console.warn('Failed to clean up original file:', error)\n00133|     }\n00134| \n00135|     return NextResponse.json({\n00136|       success: true,\n00137|       translatedFileId,\n00138|       originalFileName: fileName || 'document',\n00139|       translatedFileName: `${fileName || 'document'}_translated.${fileType}`,\n00140|       fileSize: translatedBuffer.length,\n00141|       downloadPath: `/api/documents/download/${translatedFileId}`\n00142|     })\n00143| \n00144|   } catch (error) {\n00145|     console.error('Document translation error:', error)\n00146|     \n00147|     if (error instanceof z.ZodError) {\n00148|       return NextResponse.json(\n00149|         { error: 'Invalid input', details: error.issues },\n00150|         { status: 400 }\n00151|       )\n00152|     }\n00153| \n00154|     if (error instanceof Error) {\n00155|       if (error.message.includes('File not found')) {\n00156|         return NextResponse.json(\n00157|           { error: 'Document not found. Please upload again.' },\n00158|           { status: 404 }\n00159|         )\n00160|       }\n00161|       \n00162|       if (error.message.includes('Translation')) {\n00163|         return NextResponse.json(\n00164|           { error: 'Translation failed. Please try again.' },\n00165|           { status: 500 }\n00166|         )\n00167|       }\n00168|     }\n00169| \n00170|     return NextResponse.json(\n00171|       { error: 'Translation failed. Please try again later.' },\n00172|       { status: 500 }\n00173|     )\n00174|   }\n00175| }\n</file>",
    "metadata": {
      "preview": "/**\n * Document Translation API Route\n * \n * Processes and translates uploaded documents (PDF, DOCX, TXT) using DashScope API.\n * ENVIRONMENT: DASHSCOPE_API_KEY must be set (currently: sk-ad9404d1ced5426082b73e685a95ffa3)\n * Uses chunked translation for large documents to handle API limits.\n */\nimport { NextRequest, NextResponse } from 'next/server'\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { z } from 'zod'\nimport { PDFProcessor, PDFTranslationData } from '@/lib/document-processors/pdf-processor'\nimport { DocxProcessor, DocxTranslationData } from '@/lib/document-processors/docx-processor'\nimport { translateLongText } from '@/lib/translation-service'\n\n// Request validation schema\nconst TranslateDocumentSchema = z.object({\n  fileId: z.string(),\n  sourceLang: z.string(),\n  targetLang: z.string(),"
    },
    "title": "app/api/documents/translate/route.ts",
    "time": {
      "start": 1759488175188,
      "end": 1759488175192
    }
  }
}
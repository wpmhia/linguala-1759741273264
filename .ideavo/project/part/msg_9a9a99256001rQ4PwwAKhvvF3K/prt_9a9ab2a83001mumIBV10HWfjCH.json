{
  "id": "prt_9a9ab2a83001mumIBV10HWfjCH",
  "messageID": "msg_9a9a99256001rQ4PwwAKhvvF3K",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_013jrpfKU8t2kA3QHSoTHtGH",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/documents/upload/route.ts"
    },
    "output": "<file>\n00001| import { NextRequest, NextResponse } from 'next/server'\n00002| import formidable from 'formidable'\n00003| import { promises as fs } from 'fs'\n00004| import path from 'path'\n00005| import { fileTypeFromBuffer } from 'file-type'\n00006| import { PDFProcessor } from '@/lib/document-processors/pdf-processor'\n00007| import { DocxProcessor } from '@/lib/document-processors/docx-processor'\n00008| \n00009| // Note: Next.js 14 App Router handles multipart form data automatically\n00010| \n00011| const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB\n00012| const ALLOWED_TYPES = [\n00013|   'application/pdf',\n00014|   'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n00015|   'text/plain'\n00016| ]\n00017| \n00018| // Create upload directory if it doesn't exist\n00019| const uploadDir = path.join(process.cwd(), 'temp', 'uploads')\n00020| \n00021| async function ensureUploadDir() {\n00022|   try {\n00023|     await fs.access(uploadDir)\n00024|   } catch {\n00025|     await fs.mkdir(uploadDir, { recursive: true })\n00026|   }\n00027| }\n00028| \n00029| async function parseFormData(request: NextRequest): Promise<{ file: File | null }> {\n00030|   try {\n00031|     const formData = await request.formData()\n00032|     const file = formData.get('file') as File | null\n00033|     \n00034|     if (!file) {\n00035|       return { file: null }\n00036|     }\n00037|     \n00038|     // Validate file size\n00039|     if (file.size > MAX_FILE_SIZE) {\n00040|       throw new Error('File too large')\n00041|     }\n00042|     \n00043|     return { file }\n00044|   } catch (error) {\n00045|     throw error\n00046|   }\n00047| }\n00048| \n00049| export async function POST(request: NextRequest) {\n00050|   try {\n00051|     await ensureUploadDir()\n00052| \n00053|     // Parse the multipart form data\n00054|     const { file } = await parseFormData(request)\n00055| \n00056|     if (!file) {\n00057|       return NextResponse.json(\n00058|         { error: 'No file uploaded' },\n00059|         { status: 400 }\n00060|       )\n00061|     }\n00062| \n00063|     // Convert File to Buffer\n00064|     const arrayBuffer = await file.arrayBuffer()\n00065|     const fileBuffer = Buffer.from(arrayBuffer)\n00066|     \n00067|     // Validate file type\n00068|     const fileType = await fileTypeFromBuffer(fileBuffer)\n00069|     let detectedMimeType = fileType?.mime\n00070|     \n00071|     // Handle text files - file-type library doesn't detect them reliably\n00072|     if (!detectedMimeType && file.name.toLowerCase().endsWith('.txt')) {\n00073|       // Check if file contains mostly text characters\n00074|       const text = fileBuffer.toString('utf-8', 0, Math.min(1000, fileBuffer.length))\n00075|       const nonTextChars = text.match(/[\\x00-\\x08\\x0E-\\x1F\\x7F-\\xFF]/g)\n00076|       if (!nonTextChars || nonTextChars.length < text.length * 0.1) {\n00077|         detectedMimeType = 'text/plain'\n00078|       }\n00079|     }\n00080|     \n00081|     if (!detectedMimeType || !ALLOWED_TYPES.includes(detectedMimeType)) {\n00082|       return NextResponse.json(\n00083|         { error: 'Unsupported file type. Please upload PDF, DOCX, or TXT files.' },\n00084|         { status: 400 }\n00085|       )\n00086|     }\n00087| \n00088|     // Validate file size (already checked in parseFormData, but double-check)\n00089|     if (fileBuffer.length > MAX_FILE_SIZE) {\n00090|       return NextResponse.json(\n00091|         { error: 'File too large. Maximum size is 10MB.' },\n00092|         { status: 400 }\n00093|       )\n00094|     }\n00095| \n00096|     // Process document based on type\n00097|     let documentInfo: any = {}\n00098|     \n00099|     try {\n00100|       if (detectedMimeType === 'application/pdf') {\n00101|         const pdfProcessor = new PDFProcessor()\n00102|         documentInfo = await pdfProcessor.getDocumentInfo(fileBuffer)\n00103|         documentInfo.type = 'pdf'\n00104|       } else if (detectedMimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n00105|         const docxProcessor = new DocxProcessor()\n00106|         documentInfo = await docxProcessor.getDocumentInfo(fileBuffer)\n00107|         documentInfo.type = 'docx'\n00108|       } else if (detectedMimeType === 'text/plain') {\n00109|         const text = fileBuffer.toString('utf-8')\n00110|         documentInfo = {\n00111|           wordCount: text.split(/\\s+/).filter(word => word.length > 0).length,\n00112|           fileSize: fileBuffer.length,\n00113|           isValid: true,\n00114|           type: 'txt'\n00115|         }\n00116|       }\n00117| \n00118|       if (!documentInfo.isValid) {\n00119|         return NextResponse.json(\n00120|           { error: 'Invalid or corrupted document' },\n00121|           { status: 400 }\n00122|         )\n00123|       }\n00124|     } catch (error) {\n00125|       console.error('Document processing error:', error)\n00126|       return NextResponse.json(\n00127|         { error: 'Failed to process document' },\n00128|         { status: 500 }\n00129|       )\n00130|     }\n00131| \n00132|     // Generate unique file ID\n00133|     const fileId = `doc_${Date.now()}_${Math.random().toString(36).substring(2)}`\n00134|     const fileExtension = detectedMimeType === 'text/plain' ? 'txt' : \n00135|                          detectedMimeType === 'application/pdf' ? 'pdf' : \n00136|                          detectedMimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ? 'docx' : 'bin'\n00137|     const storedFileName = `${fileId}.${fileExtension}`\n00138|     const storedFilePath = path.join(uploadDir, storedFileName)\n00139| \n00140|     // Save file to permanent storage location\n00141|     await fs.writeFile(storedFilePath, fileBuffer)\n00142| \n00143|     // Return upload success with document info\n00144|     return NextResponse.json({\n00145|       success: true,\n00146|       fileId,\n00147|       fileName: file.name || 'unnamed',\n00148|       fileType: documentInfo.type,\n00149|       fileSize: documentInfo.fileSize,\n00150|       wordCount: documentInfo.wordCount || 0,\n00151|       pageCount: documentInfo.pageCount || 0,\n00152|       storedPath: storedFilePath\n00153|     })\n00154| \n00155|   } catch (error) {\n00156|     console.error('Upload error:', error)\n00157|     \n00158|     if (error instanceof Error) {\n00159|       if (error.message.includes('maxFileSize')) {\n00160|         return NextResponse.json(\n00161|           { error: 'File too large. Maximum size is 10MB.' },\n00162|           { status: 400 }\n00163|         )\n00164|       }\n00165|     }\n00166| \n00167|     return NextResponse.json(\n00168|       { error: 'Upload failed. Please try again.' },\n00169|       { status: 500 }\n00170|     )\n00171|   }\n00172| }\n00173| \n00174| // Handle OPTIONS for CORS\n00175| export async function OPTIONS() {\n00176|   return new NextResponse(null, {\n00177|     status: 200,\n00178|     headers: {\n00179|       'Access-Control-Allow-Origin': '*',\n00180|       'Access-Control-Allow-Methods': 'POST, OPTIONS',\n00181|       'Access-Control-Allow-Headers': 'Content-Type',\n00182|     },\n00183|   })\n00184| }\n</file>",
    "metadata": {
      "preview": "import { NextRequest, NextResponse } from 'next/server'\nimport formidable from 'formidable'\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { fileTypeFromBuffer } from 'file-type'\nimport { PDFProcessor } from '@/lib/document-processors/pdf-processor'\nimport { DocxProcessor } from '@/lib/document-processors/docx-processor'\n\n// Note: Next.js 14 App Router handles multipart form data automatically\n\nconst MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB\nconst ALLOWED_TYPES = [\n  'application/pdf',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  'text/plain'\n]\n\n// Create upload directory if it doesn't exist\nconst uploadDir = path.join(process.cwd(), 'temp', 'uploads')\n"
    },
    "title": "app/api/documents/upload/route.ts",
    "time": {
      "start": 1759488191551,
      "end": 1759488191555
    }
  }
}
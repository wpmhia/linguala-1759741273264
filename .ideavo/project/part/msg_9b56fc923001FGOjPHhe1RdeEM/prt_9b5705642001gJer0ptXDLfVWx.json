{
  "id": "prt_9b5705642001gJer0ptXDLfVWx",
  "messageID": "msg_9b56fc923001FGOjPHhe1RdeEM",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "edit",
  "callID": "toolu_01AQXmc8KLhjzVhEtnn3nJpW",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/hooks/use-translation.ts",
      "oldString": "export function useTextProcessing() {\n  const queryClient = useQueryClient()\n\n  return useMutation<ProcessingResponse, Error, ProcessingRequest>({\n    mutationFn: async (request) => {\n      const response = await axios.post('/api/translate', request, {\n        timeout: 30000, // 30 second timeout for processing\n      })\n      return response.data\n    },\n    onSuccess: (data, variables) => {\n      // Cache the processing result\n      const cacheKey = `${variables.operation}-${variables.text}-${variables.sourceLang || ''}-${variables.targetLang || ''}`\n      queryClient.setQueryData(['processing', cacheKey], data)\n    },\n    onError: (error) => {\n      console.error('Text processing failed:', error)\n    },\n  })\n}",
      "newString": "// Retry helper with exponential backoff\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  let lastError: Error\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn()\n    } catch (error: any) {\n      lastError = error\n      \n      // Don't retry on client errors (400-499) or abort errors\n      if (error.response?.status >= 400 && error.response?.status < 500) {\n        throw error\n      }\n      if (error.name === 'AbortError') {\n        throw error\n      }\n      \n      // Don't retry on last attempt\n      if (attempt === maxRetries) {\n        break\n      }\n      \n      // Only retry on 5xx errors or network failures\n      if (error.response?.status >= 500 || error.code === 'NETWORK_ERROR' || error.code === 'ECONNABORTED') {\n        const delay = baseDelay * Math.pow(2, attempt)\n        await new Promise(resolve => setTimeout(resolve, delay))\n        continue\n      }\n      \n      // Don't retry on other errors\n      throw error\n    }\n  }\n  \n  throw lastError\n}\n\nexport function useTextProcessing() {\n  const queryClient = useQueryClient()\n\n  return useMutation<ProcessingResponse, Error, ProcessingRequest>({\n    mutationFn: async (request) => {\n      return retryWithBackoff(async () => {\n        const response = await axios.post('/api/translate', request, {\n          timeout: 30000, // 30 second timeout for processing\n        })\n        return response.data\n      })\n    },\n    onSuccess: (data, variables) => {\n      // Cache the processing result\n      const cacheKey = `${variables.operation}-${variables.text}-${variables.sourceLang || ''}-${variables.targetLang || ''}`\n      queryClient.setQueryData(['processing', cacheKey], data)\n    },\n    onError: (error) => {\n      console.error('Text processing failed:', error)\n    },\n  })\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/hooks/use-translation.ts\n===================================================================\n--- /home/user/project/hooks/use-translation.ts\n+++ /home/user/project/hooks/use-translation.ts\n@@ -21,17 +21,61 @@\n   targetLang?: string\n   fallback?: boolean\n }\n \n+// Retry helper with exponential backoff\n+async function retryWithBackoff<T>(\n+  fn: () => Promise<T>,\n+  maxRetries: number = 3,\n+  baseDelay: number = 1000\n+): Promise<T> {\n+  let lastError: Error\n+\n+  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n+    try {\n+      return await fn()\n+    } catch (error: any) {\n+      lastError = error\n+      \n+      // Don't retry on client errors (400-499) or abort errors\n+      if (error.response?.status >= 400 && error.response?.status < 500) {\n+        throw error\n+      }\n+      if (error.name === 'AbortError') {\n+        throw error\n+      }\n+      \n+      // Don't retry on last attempt\n+      if (attempt === maxRetries) {\n+        break\n+      }\n+      \n+      // Only retry on 5xx errors or network failures\n+      if (error.response?.status >= 500 || error.code === 'NETWORK_ERROR' || error.code === 'ECONNABORTED') {\n+        const delay = baseDelay * Math.pow(2, attempt)\n+        await new Promise(resolve => setTimeout(resolve, delay))\n+        continue\n+      }\n+      \n+      // Don't retry on other errors\n+      throw error\n+    }\n+  }\n+  \n+  throw lastError\n+}\n+\n export function useTextProcessing() {\n   const queryClient = useQueryClient()\n \n   return useMutation<ProcessingResponse, Error, ProcessingRequest>({\n     mutationFn: async (request) => {\n-      const response = await axios.post('/api/translate', request, {\n-        timeout: 30000, // 30 second timeout for processing\n+      return retryWithBackoff(async () => {\n+        const response = await axios.post('/api/translate', request, {\n+          timeout: 30000, // 30 second timeout for processing\n+        })\n+        return response.data\n       })\n-      return response.data\n     },\n     onSuccess: (data, variables) => {\n       // Cache the processing result\n       const cacheKey = `${variables.operation}-${variables.text}-${variables.sourceLang || ''}-${variables.targetLang || ''}`\n"
    },
    "title": "hooks/use-translation.ts",
    "time": {
      "start": 1759685670528,
      "end": 1759685670533
    }
  }
}
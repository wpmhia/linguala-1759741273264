{
  "id": "prt_9b5906e24001mPI5bS9uSRPd3Q",
  "messageID": "msg_9b59039c5001TdFdL7pF0L56hN",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_01UM47b71NbGvxQL7Mij3iX5",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/lib/translation-service.ts"
    },
    "output": "<file>\n00001| /**\n00002|  * Shared Translation Service for Linguala Platform\n00003|  * \n00004|  * This service uses Alibaba Cloud DashScope's Qwen translation model for high-quality translations.\n00005|  * \n00006|  * REQUIRED ENVIRONMENT VARIABLE:\n00007|  * - DASHSCOPE_API_KEY: Alibaba Cloud API key (format: sk-xxxxxxxxxxxxxxxxx)\n00008|  *   Get from: https://bailian.console.aliyun.com/ → Model Studio → Create API Key\n00009|  *   This key is already configured in .env file: sk-ad9404d1ced5426082b73e685a95ffa3\n00010|  * \n00011|  * USAGE:\n00012|  * - translateText(): For single text translation (used by main translator)\n00013|  * - translateLongText(): For document translation with chunking (used by document processor)\n00014|  * \n00015|  * FALLBACK: If API fails, falls back to dictionary-based translations for common phrases\n00016|  */\n00017| \n00018| // Language mapping for translation API - includes all frontend languages\n00019| const LANGUAGE_MAP: Record<string, string> = {\n00020|   auto: 'auto',\n00021|   \n00022|   // Popular EU Languages\n00023|   en: 'English',\n00024|   de: 'German', \n00025|   fr: 'French',\n00026|   es: 'Spanish',\n00027|   it: 'Italian',\n00028|   pt: 'Portuguese',\n00029|   pl: 'Polish',\n00030|   nl: 'Dutch',\n00031|   \n00032|   // Nordic EU Languages\n00033|   da: 'Danish',\n00034|   sv: 'Swedish',\n00035|   fi: 'Finnish',\n00036|   no: 'Norwegian',\n00037|   \n00038|   // Major World Languages\n00039|   ru: 'Russian',\n00040|   zh: 'Chinese',\n00041|   ja: 'Japanese',\n00042|   ko: 'Korean',\n00043|   ar: 'Arabic',\n00044|   hi: 'Hindi',\n00045|   tr: 'Turkish',\n00046|   th: 'Thai',\n00047|   vi: 'Vietnamese',\n00048|   \n00049|   // Other EU Languages\n00050|   ga: 'Irish',\n00051|   mt: 'Maltese',\n00052|   cs: 'Czech',\n00053|   sk: 'Slovak',\n00054|   hu: 'Hungarian',\n00055|   sl: 'Slovenian',\n00056|   hr: 'Croatian',\n00057|   bg: 'Bulgarian',\n00058|   ro: 'Romanian',\n00059|   lt: 'Lithuanian',\n00060|   lv: 'Latvian',\n00061|   et: 'Estonian',\n00062|   el: 'Greek',\n00063| }\n00064| \n00065| // Fallback translation for common phrases\n00066| function getFallbackTranslation(text: string, targetLanguage: string): string | null {\n00067|   const lowerText = text.toLowerCase().trim()\n00068|   \n00069|   const commonPhrases: Record<string, Record<string, string>> = {\n00070|     'hello': {\n00071|       'Danish': 'Hej',\n00072|       'Swedish': 'Hej', \n00073|       'Norwegian': 'Hei',\n00074|       'Finnish': 'Hei',\n00075|       'German': 'Hallo',\n00076|       'French': 'Bonjour',\n00077|       'Spanish': 'Hola',\n00078|       'Italian': 'Ciao',\n00079|       'Portuguese': 'Olá',\n00080|       'Dutch': 'Hallo',\n00081|       'Polish': 'Cześć',\n00082|       'Russian': 'Привет'\n00083|     },\n00084|     'good morning': {\n00085|       'Danish': 'God morgen',\n00086|       'Swedish': 'God morgon',\n00087|       'Norwegian': 'God morgen', \n00088|       'Finnish': 'Hyvää huomenta',\n00089|       'German': 'Guten Morgen',\n00090|       'French': 'Bonjour',\n00091|       'Spanish': 'Buenos días',\n00092|       'Dutch': 'Goedemorgen'\n00093|     },\n00094|     'thank you': {\n00095|       'Danish': 'Tak',\n00096|       'Swedish': 'Tack',\n00097|       'Norwegian': 'Takk',\n00098|       'Finnish': 'Kiitos',\n00099|       'German': 'Danke',\n00100|       'French': 'Merci',\n00101|       'Spanish': 'Gracias',\n00102|       'Dutch': 'Dank je'\n00103|     }\n00104|   }\n00105|   \n00106|   for (const [phrase, translations] of Object.entries(commonPhrases)) {\n00107|     if (lowerText.includes(phrase)) {\n00108|       return translations[targetLanguage] || null\n00109|     }\n00110|   }\n00111|   \n00112|   return null\n00113| }\n00114| \n00115| export interface TranslationResult {\n00116|   translatedText: string\n00117|   sourceLang: string\n00118|   targetLang: string\n00119|   fallback?: boolean\n00120| }\n00121| \n00122| export async function translateText(\n00123|   text: string, \n00124|   sourceLang: string, \n00125|   targetLang: string,\n00126|   options?: {\n00127|     domain?: string\n00128|     glossary?: Array<{ source: string; target: string }>\n00129|   }\n00130| ): Promise<TranslationResult> {\n00131|   try {\n00132|     if (!text || !targetLang) {\n00133|       throw new Error('Text and target language are required')\n00134|     }\n00135| \n00136|     // Prepare the translation options\n00137|     const targetLanguage = LANGUAGE_MAP[targetLang] || targetLang\n00138|     \n00139|     // Try fallback first for better reliability\n00140|     const fallbackTranslation = getFallbackTranslation(text, targetLanguage)\n00141|     if (fallbackTranslation) {\n00142|       return {\n00143|         translatedText: fallbackTranslation,\n00144|         sourceLang,\n00145|         targetLang,\n00146|         fallback: true\n00147|       }\n00148|     }\n00149| \n00150|     // For now, use a simple pattern-based translation to avoid API hanging issues\n00151|     // This is a temporary solution until the network issue is resolved\n00152|     const simpleTranslations: Record<string, Record<string, string>> = {\n00153|       'test': { 'Spanish': 'prueba', 'French': 'test', 'German': 'Test' },\n00154|       'hello': { 'Spanish': 'hola', 'French': 'bonjour', 'German': 'hallo' },\n00155|       'world': { 'Spanish': 'mundo', 'French': 'monde', 'German': 'Welt' },\n00156|       'document': { 'Spanish': 'documento', 'French': 'document', 'German': 'Dokument' },\n00157|       'translation': { 'Spanish': 'traducción', 'French': 'traduction', 'German': 'Übersetzung' }\n00158|     }\n00159| \n00160|     const lowerText = text.toLowerCase().trim()\n00161|     for (const [key, translations] of Object.entries(simpleTranslations)) {\n00162|       if (lowerText.includes(key)) {\n00163|         return {\n00164|           translatedText: translations[targetLanguage] || text,\n00165|           sourceLang,\n00166|           targetLang,\n00167|           fallback: true\n00168|         }\n00169|       }\n00170|     }\n00171| \n00172|     // If no pattern matches, provide a basic response\n00173|     return {\n00174|       translatedText: `[Translated to ${targetLanguage}] ${text}`,\n00175|       sourceLang,\n00176|       targetLang,\n00177|       fallback: true\n00178|     }\n00179|     \n00180|   } catch (error) {\n00181|     console.error('Translation error:', error)\n00182|     \n00183|     return {\n00184|       translatedText: `Translation error: ${text}`,\n00185|       sourceLang,\n00186|       targetLang,\n00187|       fallback: true\n00188|     }\n00189|   }\n00190| }\n00191| \n00192| /**\n00193|  * Verify DashScope API configuration\n00194|  * Checks if API key is properly configured and accessible\n00195|  */\n00196| export function verifyApiConfiguration(): { configured: boolean; keyPreview?: string; error?: string } {\n00197|   const apiKey = process.env.DASHSCOPE_API_KEY\n00198|   \n00199|   if (!apiKey) {\n00200|     return {\n00201|       configured: false,\n00202|       error: 'DASHSCOPE_API_KEY not found in environment variables. Please set it in .env file.'\n00203|     }\n00204|   }\n00205|   \n00206|   if (!apiKey.startsWith('sk-')) {\n00207|     return {\n00208|       configured: false,\n00209|       error: 'Invalid API key format. DashScope API keys should start with \"sk-\"'\n00210|     }\n00211|   }\n00212|   \n00213|   return {\n00214|     configured: true,\n00215|     keyPreview: `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 4)}`\n00216|   }\n00217| }\n00218| \n00219| export async function translateLongText(text: string, sourceLang: string, targetLang: string): Promise<string> {\n00220|   // Split long text into chunks to handle API limits\n00221|   const MAX_CHUNK_SIZE = 4000 // Conservative limit for translation API\n00222|   const chunks: string[] = []\n00223|   \n00224|   // Split by paragraphs first\n00225|   const paragraphs = text.split('\\n\\n').filter(p => p.trim())\n00226|   \n00227|   let currentChunk = ''\n00228|   for (const paragraph of paragraphs) {\n00229|     if (currentChunk.length + paragraph.length > MAX_CHUNK_SIZE && currentChunk.length > 0) {\n00230|       chunks.push(currentChunk.trim())\n00231|       currentChunk = paragraph\n00232|     } else {\n00233|       currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n00234|     }\n00235|   }\n00236|   \n00237|   if (currentChunk.trim()) {\n00238|     chunks.push(currentChunk.trim())\n00239|   }\n00240| \n00241|   // Translate each chunk\n00242|   const translatedChunks: string[] = []\n00243|   for (let i = 0; i < chunks.length; i++) {\n00244|     console.log(`Translating chunk ${i + 1}/${chunks.length}`)\n00245|     try {\n00246|       const result = await translateText(chunks[i], sourceLang, targetLang)\n00247|       translatedChunks.push(result.translatedText)\n00248|       \n00249|       // Add small delay to avoid rate limiting\n00250|       if (i < chunks.length - 1) {\n00251|         await new Promise(resolve => setTimeout(resolve, 500))\n00252|       }\n00253|     } catch (error) {\n00254|       console.error(`Error translating chunk ${i + 1}:`, error)\n00255|       // Use original text as fallback\n00256|       translatedChunks.push(chunks[i])\n00257|     }\n00258|   }\n00259| \n00260|   return translatedChunks.join('\\n\\n')\n00261| }\n</file>",
    "metadata": {
      "preview": "/**\n * Shared Translation Service for Linguala Platform\n * \n * This service uses Alibaba Cloud DashScope's Qwen translation model for high-quality translations.\n * \n * REQUIRED ENVIRONMENT VARIABLE:\n * - DASHSCOPE_API_KEY: Alibaba Cloud API key (format: sk-xxxxxxxxxxxxxxxxx)\n *   Get from: https://bailian.console.aliyun.com/ → Model Studio → Create API Key\n *   This key is already configured in .env file: sk-ad9404d1ced5426082b73e685a95ffa3\n * \n * USAGE:\n * - translateText(): For single text translation (used by main translator)\n * - translateLongText(): For document translation with chunking (used by document processor)\n * \n * FALLBACK: If API fails, falls back to dictionary-based translations for common phrases\n */\n\n// Language mapping for translation API - includes all frontend languages\nconst LANGUAGE_MAP: Record<string, string> = {\n  auto: 'auto',"
    },
    "title": "lib/translation-service.ts",
    "time": {
      "start": 1759687765812,
      "end": 1759687765814
    }
  }
}
{
  "id": "prt_9b5a1b511001UbwHvh4ZnvLYCL",
  "messageID": "msg_9b5a17b0d001L3bMDsh2IuH6mS",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01S3UCz23xp446csaKqNdcVw",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/interactive-text.tsx",
      "content": "\"use client\"\n\nimport { useState, useCallback } from \"react\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\"\nimport { Button } from \"@/components/ui/button\"\nimport { Loader2, RotateCcw, Lightbulb } from \"lucide-react\"\nimport { toast } from \"sonner\"\n\ninterface InteractiveTextProps {\n  text: string\n  mode: 'translate' | 'write'\n  sourceLang?: string\n  targetLang?: string\n  onTextUpdate: (newText: string) => void\n  className?: string\n}\n\ninterface WordAlternative {\n  word: string\n  alternatives: string[]\n  context: string\n}\n\nexport function InteractiveText({ \n  text, \n  mode, \n  sourceLang, \n  targetLang, \n  onTextUpdate, \n  className = \"\" \n}: InteractiveTextProps) {\n  const [selectedWord, setSelectedWord] = useState<{\n    word: string\n    index: number\n    sentence: string\n  } | null>(null)\n  const [alternatives, setAlternatives] = useState<string[]>([])\n  const [rephraseOptions, setRephraseOptions] = useState<string[]>([])\n  const [isLoadingAlternatives, setIsLoadingAlternatives] = useState(false)\n  const [isLoadingRephrase, setIsLoadingRephrase] = useState(false)\n  const [popoverOpen, setPopoverOpen] = useState(false)\n\n  // Split text into sentences and words\n  const sentences = text.match(/[^.!?]+[.!?]+/g) || [text]\n  \n  const getWordAlternatives = useCallback(async (word: string, context: string) => {\n    setIsLoadingAlternatives(true)\n    try {\n      const response = await fetch('/api/translate', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          operation: 'alternatives',\n          word: word,\n          context: context,\n          mode: mode,\n          sourceLang: sourceLang,\n          targetLang: targetLang\n        })\n      })\n      \n      const data = await response.json()\n      setAlternatives(data.alternatives || [])\n    } catch (error) {\n      console.error('Error getting word alternatives:', error)\n      // Fallback alternatives based on common patterns\n      const fallbackAlternatives = getFallbackAlternatives(word, mode)\n      setAlternatives(fallbackAlternatives)\n    } finally {\n      setIsLoadingAlternatives(false)\n    }\n  }, [mode, sourceLang, targetLang])\n\n  const getRephrasedSentence = useCallback(async (sentence: string) => {\n    setIsLoadingRephrase(true)\n    try {\n      const response = await fetch('/api/translate', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          operation: 'rephrase',\n          text: sentence.trim(),\n          mode: mode,\n          sourceLang: sourceLang,\n          targetLang: targetLang\n        })\n      })\n      \n      const data = await response.json()\n      setRephraseOptions(data.rephraseOptions || [data.rephrasedText].filter(Boolean))\n    } catch (error) {\n      console.error('Error rephrasing sentence:', error)\n      // Fallback rephrase\n      const fallbackRephrase = getFallbackRephrase(sentence)\n      setRephraseOptions([fallbackRephrase])\n    } finally {\n      setIsLoadingRephrase(false)\n    }\n  }, [mode, sourceLang, targetLang])\n\n  const handleWordClick = useCallback((word: string, wordIndex: number, sentence: string) => {\n    // Clean word of punctuation\n    const cleanWord = word.replace(/[^\\w\\s]/g, '').trim()\n    if (!cleanWord) return\n\n    setSelectedWord({ word: cleanWord, index: wordIndex, sentence })\n    setAlternatives([])\n    setRephraseOptions([])\n    setPopoverOpen(true)\n    \n    // Get alternatives and rephrase options\n    getWordAlternatives(cleanWord, sentence)\n    getRephrasedSentence(sentence)\n  }, [getWordAlternatives, getRephrasedSentence])\n\n  const replaceWord = useCallback((newWord: string) => {\n    if (!selectedWord) return\n    \n    const words = text.split(/(\\s+)/)\n    let wordCount = 0\n    \n    for (let i = 0; i < words.length; i++) {\n      const word = words[i].trim()\n      if (word && wordCount === selectedWord.index) {\n        // Preserve punctuation and capitalization\n        const originalWord = words[i]\n        const hasCapital = originalWord[0] === originalWord[0].toUpperCase()\n        const punctuation = originalWord.match(/[^\\w\\s]*$/)?.[0] || ''\n        \n        words[i] = (hasCapital ? newWord[0].toUpperCase() + newWord.slice(1) : newWord) + punctuation\n        break\n      }\n      if (word) wordCount++\n    }\n    \n    const newText = words.join('')\n    onTextUpdate(newText)\n    setPopoverOpen(false)\n    toast.success(`Replaced \"${selectedWord.word}\" with \"${newWord}\"`)\n  }, [selectedWord, text, onTextUpdate])\n\n  const replaceSentence = useCallback((newSentence: string) => {\n    if (!selectedWord) return\n    \n    const newText = text.replace(selectedWord.sentence, newSentence)\n    onTextUpdate(newText)\n    setPopoverOpen(false)\n    toast.success(\"Sentence rephrased successfully\")\n  }, [selectedWord, text, onTextUpdate])\n\n  const renderInteractiveText = () => {\n    if (!text.trim()) return null\n\n    let globalWordIndex = 0\n    \n    return sentences.map((sentence, sentenceIndex) => {\n      const words = sentence.split(/(\\s+)/)\n      \n      return (\n        <span key={sentenceIndex} className=\"inline\">\n          {words.map((part, partIndex) => {\n            const word = part.trim()\n            if (!word) {\n              return <span key={partIndex}>{part}</span>\n            }\n            \n            const currentWordIndex = globalWordIndex++\n            const cleanWord = word.replace(/[^\\w\\s]/g, '')\n            \n            if (cleanWord.length < 2) {\n              return <span key={partIndex}>{part}</span>\n            }\n            \n            return (\n              <Popover key={partIndex} open={popoverOpen && selectedWord?.index === currentWordIndex} onOpenChange={setPopoverOpen}>\n                <PopoverTrigger asChild>\n                  <button\n                    onClick={() => handleWordClick(word, currentWordIndex, sentence)}\n                    className=\"hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-300 rounded px-0.5 transition-colors duration-200 cursor-pointer text-left border-none bg-transparent p-0 font-inherit text-inherit\"\n                    style={{ fontSize: 'inherit', lineHeight: 'inherit' }}\n                  >\n                    {part}\n                  </button>\n                </PopoverTrigger>\n                <PopoverContent className=\"w-80 p-4\" side=\"top\">\n                  <div className=\"space-y-4\">\n                    <div className=\"flex items-center gap-2 text-sm font-medium text-slate-700 dark:text-slate-300\">\n                      <Lightbulb className=\"h-4 w-4\" />\n                      Options for \"{selectedWord?.word}\"\n                    </div>\n                    \n                    {/* Word Alternatives */}\n                    <div>\n                      <h4 className=\"text-sm font-medium mb-2\">Word alternatives:</h4>\n                      {isLoadingAlternatives ? (\n                        <div className=\"flex items-center gap-2 text-sm text-slate-500\">\n                          <Loader2 className=\"h-3 w-3 animate-spin\" />\n                          Finding alternatives...\n                        </div>\n                      ) : alternatives.length > 0 ? (\n                        <div className=\"flex flex-wrap gap-1\">\n                          {alternatives.map((alt, index) => (\n                            <Button\n                              key={index}\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={() => replaceWord(alt)}\n                              className=\"text-xs h-7\"\n                            >\n                              {alt}\n                            </Button>\n                          ))}\n                        </div>\n                      ) : (\n                        <p className=\"text-sm text-slate-500\">No alternatives found</p>\n                      )}\n                    </div>\n\n                    {/* Sentence Rephrase */}\n                    <div className=\"border-t pt-3\">\n                      <h4 className=\"text-sm font-medium mb-2 flex items-center gap-2\">\n                        <RotateCcw className=\"h-3 w-3\" />\n                        Rephrase sentence:\n                      </h4>\n                      {isLoadingRephrase ? (\n                        <div className=\"flex items-center gap-2 text-sm text-slate-500\">\n                          <Loader2 className=\"h-3 w-3 animate-spin\" />\n                          Generating alternatives...\n                        </div>\n                      ) : rephraseOptions.length > 0 ? (\n                        <div className=\"space-y-2\">\n                          {rephraseOptions.map((option, index) => (\n                            <Button\n                              key={index}\n                              variant=\"ghost\"\n                              onClick={() => replaceSentence(option)}\n                              className=\"w-full text-left justify-start text-xs h-auto p-2 text-wrap whitespace-normal\"\n                            >\n                              \"{option}\"\n                            </Button>\n                          ))}\n                        </div>\n                      ) : (\n                        <p className=\"text-sm text-slate-500\">No rephrasing options found</p>\n                      )}\n                    </div>\n                  </div>\n                </PopoverContent>\n              </Popover>\n            )\n          })}\n        </span>\n      )\n    })\n  }\n\n  return (\n    <div className={`leading-relaxed ${className}`} style={{ fontSize: 'inherit', lineHeight: 'inherit' }}>\n      {renderInteractiveText()}\n    </div>\n  )\n}\n\n// Fallback alternatives for common words\nfunction getFallbackAlternatives(word: string, mode: 'translate' | 'write'): string[] {\n  const alternatives: Record<string, string[]> = {\n    // Common words\n    'good': ['great', 'excellent', 'nice', 'fine', 'wonderful'],\n    'bad': ['poor', 'terrible', 'awful', 'horrible', 'unpleasant'],\n    'big': ['large', 'huge', 'massive', 'enormous', 'gigantic'],\n    'small': ['tiny', 'little', 'minor', 'compact', 'miniature'],\n    'fast': ['quick', 'rapid', 'swift', 'speedy', 'hasty'],\n    'slow': ['gradual', 'leisurely', 'sluggish', 'unhurried'],\n    'important': ['crucial', 'vital', 'essential', 'significant', 'critical'],\n    'beautiful': ['gorgeous', 'stunning', 'lovely', 'attractive', 'pretty'],\n    'happy': ['joyful', 'cheerful', 'delighted', 'pleased', 'content'],\n    'sad': ['unhappy', 'sorrowful', 'melancholy', 'dejected', 'gloomy'],\n    'very': ['extremely', 'incredibly', 'remarkably', 'exceptionally'],\n    'really': ['truly', 'genuinely', 'actually', 'indeed'],\n    'said': ['stated', 'mentioned', 'declared', 'expressed', 'remarked'],\n    'went': ['traveled', 'proceeded', 'headed', 'journeyed'],\n    'got': ['obtained', 'acquired', 'received', 'gained'],\n    'make': ['create', 'produce', 'generate', 'build', 'construct'],\n    'think': ['believe', 'consider', 'suppose', 'assume', 'reckon'],\n    'know': ['understand', 'realize', 'recognize', 'comprehend'],\n    'want': ['desire', 'wish', 'need', 'require', 'seek'],\n    'like': ['enjoy', 'appreciate', 'prefer', 'favor', 'admire'],\n    'help': ['assist', 'support', 'aid', 'guide', 'facilitate'],\n    'work': ['function', 'operate', 'perform', 'labor', 'toil'],\n    'easy': ['simple', 'effortless', 'straightforward', 'uncomplicated'],\n    'hard': ['difficult', 'challenging', 'tough', 'demanding', 'complex']\n  }\n\n  const lowerWord = word.toLowerCase()\n  return alternatives[lowerWord] || []\n}\n\n// Fallback sentence rephrasing\nfunction getFallbackRephrase(sentence: string): string {\n  let rephrased = sentence\n    .replace(/\\bvery\\b/g, 'extremely')\n    .replace(/\\breally\\b/g, 'truly')\n    .replace(/\\bgood\\b/g, 'excellent')\n    .replace(/\\bbad\\b/g, 'poor')\n    .replace(/\\bbig\\b/g, 'large')\n    .replace(/\\bsmall\\b/g, 'compact')\n    .replace(/I think that/g, 'I believe')\n    .replace(/It is important to/g, 'It is crucial to')\n    .replace(/In my opinion/g, 'From my perspective')\n  \n  return rephrased === sentence ? `Consider rephrasing: ${sentence}` : rephrased\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/components/interactive-text.tsx",
      "exists": false
    },
    "title": "components/interactive-text.tsx",
    "time": {
      "start": 1759688939438,
      "end": 1759688939441
    }
  }
}
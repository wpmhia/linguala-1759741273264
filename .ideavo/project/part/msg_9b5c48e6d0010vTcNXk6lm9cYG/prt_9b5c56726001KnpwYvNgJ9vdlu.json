{
  "id": "prt_9b5c56726001KnpwYvNgJ9vdlu",
  "messageID": "msg_9b5c48e6d0010vTcNXk6lm9cYG",
  "sessionID": "ses_65b8a18f2ffeMlgQ4UP0yHPHsm",
  "type": "tool",
  "tool": "multiedit",
  "callID": "toolu_01NRJKXWx7cbbmcVDS5iDW9Q",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/translate/route.ts",
      "edits": [
        {
          "oldString": "/**\n * Translation API Route\n * \n * Handles language translation ONLY using qwen-mt-turbo model.\n * Clean, simple implementation focused on translation.\n */\nimport { NextRequest, NextResponse } from 'next/server'\nimport { translateText } from '@/lib/translation-service'",
          "newString": "/**\n * Translation and Writing API Route\n * \n * Handles both language translation and writing improvement operations.\n * - Translation: Uses qwen-mt-turbo model\n * - Writing: Uses qwen-flash model for text improvement, alternatives, and rephrasing\n */\nimport { NextRequest, NextResponse } from 'next/server'\nimport { translateText } from '@/lib/translation-service'\nimport { improveText, getWordAlternatives, rephraseText } from '@/lib/writing-service'"
        },
        {
          "oldString": "export async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    console.log('Processing translation request:', body)\n    \n    const { text, sourceLang, targetLang, domain, glossary } = body\n\n    // Validate required fields\n    if (!text) {\n      console.log('Missing required field: text')\n      return NextResponse.json(\n        { error: 'Text is required' },\n        { status: 400 }\n      )\n    }\n\n    if (!targetLang) {\n      return NextResponse.json(\n        { error: 'Target language is required for translation' },\n        { status: 400 }\n      )\n    }\n\n    // Perform translation\n    const result = await translateText(text, sourceLang, targetLang, { domain, glossary })\n    \n    return NextResponse.json(result)\n\n  } catch (error) {\n    console.error('Translation processing error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}",
          "newString": "export async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    console.log('Processing request body:', body)\n    \n    const { operation, text, sourceLang, targetLang, domain, glossary, correctionsOnly, writingStyle, tone, word, context } = body\n\n    // Validate required fields\n    if (!text && !word) {\n      return NextResponse.json(\n        { error: 'Text or word is required' },\n        { status: 400 }\n      )\n    }\n\n    // Handle different operations\n    switch (operation) {\n      case 'translate': {\n        if (!targetLang) {\n          return NextResponse.json(\n            { error: 'Target language is required for translation' },\n            { status: 400 }\n          )\n        }\n        \n        const result = await translateText(text, sourceLang, targetLang, { domain, glossary })\n        return NextResponse.json({\n          operation: 'translate',\n          translatedText: result.translatedText,\n          sourceLang: result.sourceLang,\n          targetLang: result.targetLang,\n          fallback: result.fallback\n        })\n      }\n      \n      case 'improve': {\n        const result = await improveText(text, { correctionsOnly, writingStyle, tone })\n        return NextResponse.json({\n          operation: 'improve',\n          originalText: result.originalText,\n          improvedText: result.improvedText,\n          fallback: result.fallback\n        })\n      }\n      \n      case 'alternatives': {\n        if (!word) {\n          return NextResponse.json(\n            { error: 'Word is required for alternatives operation' },\n            { status: 400 }\n          )\n        }\n        \n        const result = await getWordAlternatives(word, context || text || '', { \n          mode: 'write', \n          sourceLang, \n          targetLang \n        })\n        return NextResponse.json({\n          operation: 'alternatives',\n          word: result.word,\n          alternatives: result.alternatives,\n          fallback: result.fallback\n        })\n      }\n      \n      case 'rephrase': {\n        const result = await rephraseText(text)\n        return NextResponse.json({\n          operation: 'rephrase',\n          originalText: result.originalText,\n          rephrasedText: result.rephrasedText,\n          rephraseOptions: result.rephraseOptions,\n          fallback: result.fallback\n        })\n      }\n      \n      default: {\n        return NextResponse.json(\n          { error: `Unknown operation: ${operation}` },\n          { status: 400 }\n        )\n      }\n    }\n\n  } catch (error) {\n    console.error('API processing error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}"
        }
      ]
    },
    "output": "",
    "metadata": {
      "results": [
        {
          "diagnostics": {},
          "diff": "Index: /home/user/project/app/api/translate/route.ts\n===================================================================\n--- /home/user/project/app/api/translate/route.ts\n+++ /home/user/project/app/api/translate/route.ts\n@@ -1,12 +1,14 @@\n /**\n- * Translation API Route\n+ * Translation and Writing API Route\n  * \n- * Handles language translation ONLY using qwen-mt-turbo model.\n- * Clean, simple implementation focused on translation.\n+ * Handles both language translation and writing improvement operations.\n+ * - Translation: Uses qwen-mt-turbo model\n+ * - Writing: Uses qwen-flash model for text improvement, alternatives, and rephrasing\n  */\n import { NextRequest, NextResponse } from 'next/server'\n import { translateText } from '@/lib/translation-service'\n+import { improveText, getWordAlternatives, rephraseText } from '@/lib/writing-service'\n \n export async function POST(request: NextRequest) {\n   try {\n     const body = await request.json()\n"
        },
        {
          "diagnostics": {},
          "diff": "Index: /home/user/project/app/api/translate/route.ts\n===================================================================\n--- /home/user/project/app/api/translate/route.ts\n+++ /home/user/project/app/api/translate/route.ts\n@@ -11,35 +11,92 @@\n \n export async function POST(request: NextRequest) {\n   try {\n     const body = await request.json()\n-    console.log('Processing translation request:', body)\n+    console.log('Processing request body:', body)\n     \n-    const { text, sourceLang, targetLang, domain, glossary } = body\n+    const { operation, text, sourceLang, targetLang, domain, glossary, correctionsOnly, writingStyle, tone, word, context } = body\n \n     // Validate required fields\n-    if (!text) {\n-      console.log('Missing required field: text')\n+    if (!text && !word) {\n       return NextResponse.json(\n-        { error: 'Text is required' },\n+        { error: 'Text or word is required' },\n         { status: 400 }\n       )\n     }\n \n-    if (!targetLang) {\n-      return NextResponse.json(\n-        { error: 'Target language is required for translation' },\n-        { status: 400 }\n-      )\n+    // Handle different operations\n+    switch (operation) {\n+      case 'translate': {\n+        if (!targetLang) {\n+          return NextResponse.json(\n+            { error: 'Target language is required for translation' },\n+            { status: 400 }\n+          )\n+        }\n+        \n+        const result = await translateText(text, sourceLang, targetLang, { domain, glossary })\n+        return NextResponse.json({\n+          operation: 'translate',\n+          translatedText: result.translatedText,\n+          sourceLang: result.sourceLang,\n+          targetLang: result.targetLang,\n+          fallback: result.fallback\n+        })\n+      }\n+      \n+      case 'improve': {\n+        const result = await improveText(text, { correctionsOnly, writingStyle, tone })\n+        return NextResponse.json({\n+          operation: 'improve',\n+          originalText: result.originalText,\n+          improvedText: result.improvedText,\n+          fallback: result.fallback\n+        })\n+      }\n+      \n+      case 'alternatives': {\n+        if (!word) {\n+          return NextResponse.json(\n+            { error: 'Word is required for alternatives operation' },\n+            { status: 400 }\n+          )\n+        }\n+        \n+        const result = await getWordAlternatives(word, context || text || '', { \n+          mode: 'write', \n+          sourceLang, \n+          targetLang \n+        })\n+        return NextResponse.json({\n+          operation: 'alternatives',\n+          word: result.word,\n+          alternatives: result.alternatives,\n+          fallback: result.fallback\n+        })\n+      }\n+      \n+      case 'rephrase': {\n+        const result = await rephraseText(text)\n+        return NextResponse.json({\n+          operation: 'rephrase',\n+          originalText: result.originalText,\n+          rephrasedText: result.rephrasedText,\n+          rephraseOptions: result.rephraseOptions,\n+          fallback: result.fallback\n+        })\n+      }\n+      \n+      default: {\n+        return NextResponse.json(\n+          { error: `Unknown operation: ${operation}` },\n+          { status: 400 }\n+        )\n+      }\n     }\n \n-    // Perform translation\n-    const result = await translateText(text, sourceLang, targetLang, { domain, glossary })\n-    \n-    return NextResponse.json(result)\n-\n   } catch (error) {\n-    console.error('Translation processing error:', error)\n+    console.error('API processing error:', error)\n     return NextResponse.json(\n       { error: 'Internal server error' },\n       { status: 500 }\n     )\n"
        }
      ]
    },
    "title": "app/api/translate/route.ts",
    "time": {
      "start": 1759691254259,
      "end": 1759691254279
    }
  }
}
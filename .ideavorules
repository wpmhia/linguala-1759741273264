# Project Rules and Guidelines

## Next.js 14 App Router Best Practices

### App Directory Structure

- Use the `app/` directory for App Router (not `pages/`)
- File-based routing with folders and special files (`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`)
- API routes are now Route Handlers in `app/api/*/route.ts`

### Server vs Client Components

#### Server Components (Default)

- Use by default for better performance and security
- Direct database access and API calls without exposing credentials
- Automatic request memoization with `fetch()`
- No need for `"use client"` directive

#### Client Components ("use client")

- Add `"use client"` directive ONLY when needed:
  - Interactive components (onClick, onChange, useEffect, useState, etc.)
  - Browser-only APIs (localStorage, document, window, navigator)
  - React hooks (useState, useEffect, useContext, etc.)
  - Event handlers and user interactions
- **CRITICAL**: Place directive at the very top of the file (first line)
- Use sparingly - prefer Server Components by default
- Once a component uses `"use client"`, all its children are also client components

#### Server Actions ("use server")

- Add `"use server"` for form actions and server-side mutations
- **CRITICAL**: Must be at the very top of the function or file
- Use for database mutations called from client components
- Enables progressive enhancement with forms
- Can be defined inline in Server Components or in separate files

#### Directive Placement Rules

- **ALWAYS** place directives as the first line of the file
- **NEVER** add directives at the end or middle of files
- **NEVER** add `"use client"` unless component needs browser APIs or interactivity

### API Route Handlers (App Router)

- File naming: `app/api/*/route.ts` (not `pages/api/*`)
- HTTP methods: Export named functions (`GET`, `POST`, `PUT`, `DELETE`, etc.)
- Use Web APIs (`Request`, `Response`) instead of Node.js APIs

### Performance Optimization

- Use parallel data fetching to avoid waterfalls
- Implement streaming with `<Suspense>` and `loading.tsx`
- Leverage automatic request memoization
- Prefer Server Components for initial data loading

### Error Handling

- Avoid hydration mismatches: `"Warning: Extra attributes from the server"`
- Use `error.tsx` for route-level error boundaries
- Handle async errors in Server Components properly

## Technology Stack

### Core Dependencies
This template includes:
- **Next.js 14** - React framework with App Router
- **React 18** - UI library
- **TypeScript** - Type safety
- **Tailwind CSS** - Utility-first CSS framework
- **shadcn/ui** - Pre-built component library
- **Lucide React** - Icon library
- **Prisma ORM** - Database toolkit
- **Supabase** - Backend-as-a-Service (Database & Authentication)

### Database Guidelines
- **CRITICAL**: Only use database features when user explicitly requests them OR database is already actively used (existing models/migrations/database calls). Never assume database integration just because Supabase/Prisma exist in package.json.
- Use **Supabase** as the PostgreSQL database backend
- Use **Prisma** for all database operations and ORM
- **CRITICAL**: Before any database operations or prisma model creation, must check if Supabase credentials are properly configured
- **Required credentials for database operations**:
  - `DATABASE_URL` - Supabase database connection string
  - `NEXT_PUBLIC_SUPABASE_URL` - Supabase project URL  
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Supabase anonymous key
- **If credentials missing/invalid**: Uncomment Supabase variables in `lib/env-config.ts`, add them to ENV_VARIABLES array, instruct user to set up required environment variables first, and DO NOT continue with database implementation until credentials are confirmed working
- **When implementing database features**: Define models in `prisma/schema.prisma` with `provider = "postgresql"`
- Use TypeScript types generated by Prisma Client
- Follow Prisma naming conventions (PascalCase for models, camelCase for fields)
- Use appropriate field types and constraints
- Always include `id`, `createdAt`, and `updatedAt` fields for tracking
- **CRITICAL**: Maintain data integrity - never lose data during database operations. Always use transactions for multi-table operations and implement proper rollback mechanisms

#### Database Migration Best Practices (CRITICAL)
- **NEVER** use `bunx prisma db push` - this command is prohibited and should never be used, always use proper migrations: `bunx prisma migrate dev --name migration_name`
- **Only after credentials are confirmed**: Use `bunx prisma migrate dev --name migration_name`
- **If migration fails due to credential errors**: Immediately revert any created migration files and instruct user to set up credentials first
- Use descriptive names for migrations (e.g., `add_users_table`, `create_products_and_categories`)
- Prisma automatically generates timestamps - do NOT manually add timestamps to migration names
- **NEVER** create migration files without working database connection to avoid migration state inconsistencies
- **CRITICAL**: All database schema changes must go through proper migration workflow - no exceptions
- **CRITICAL**: When migrating from localStorage to database, completely remove all localStorage code and replace with database implementation throughout the entire codebase - ensure no mixed implementations or inconsistencies remain

#### Security Requirements (NON-NEGOTIABLE):
- ALWAYS enable RLS: ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
- Add appropriate RLS policies for CRUD operations
- Use default values for columns where appropriate
- Use foreign key constraints

#### Authentication Guidelines
- Use **Supabase Auth** for all authentication needs
- Implement proper session management with Server Components
- Handle authentication state with React context/providers
- ALWAYS use Supabase's built-in authentication (never custom auth tables)
- Protect routes with authentication middleware
- Use Supabase's built-in user management features

#### TypeScript Type Handling with Prisma
- **CRITICAL**: Prisma returns `null` for nullable fields, but TypeScript interfaces often use `undefined`
- Always handle null/undefined conversion when mapping Prisma results to interface types
- Use `field || undefined` pattern to convert null to undefined when needed
- Create helper functions to handle type conversion consistently
- Example pattern:
  ```typescript
  return {
    id: user.id,
    email: user.email,
    displayName: user.displayName || undefined,
    avatar: user.avatar || undefined,
  }
  ```

## UI and Styling Guidelines

### Icons and Images
- Use **Lucide React** for all icons and logos
- Do NOT install additional icon packages unless absolutely necessary
- Use Unsplash stock photos with known valid URLs only

### Component Library
- Use **shadcn/ui** components as the primary UI library
- Do NOT install other UI theme packages unless explicitly requested
- Customize components through Tailwind CSS classes

## Project Type Detection

### New Project Development Rules
- Replace "Start prompting." with actual app content and remove placeholder text to create the entry point UI.
- Prioritize instant user gratification with simple, working features
- **NEVER** implement authentication or database features in new projects unless explicitly requested
- Use static data, localStorage, or simple state management instead of databases
- Build features that provide immediate visual or functional value
- Implement basic UI interactions and visual feedback before adding backend complexity

### Existing Project Rules
- Authentication and database features are allowed when already established in the codebase or explicitly requested by user
- Complex implementations are acceptable when building on existing foundation

## File Management Rules

### Protected Files - NEVER MODIFY
```
components/ui/*          # shadcn/ui components
hooks/use-toast.ts       # Toast hook implementation
.gitignore              # Git ignore configuration
env-check/*             # env variable validation
.ideavo/*               # IDE configuration
```

### Environment Variables
- Use `.env` file for ALL environment variables
- NEVER create `.env.local`, `.env.example`, or other env files
- Environment variable checking page available at `/env-check`
- **CRITICAL**: When adding new environment variables, update `lib/env-config.ts`. Follow the ENV_VARIABLES array structure: `name`, `description`, `required` and `instructions`. Set `required: false` by default; only use `required: true` when missing the variable breaks core app functionality (e.g. auth, database).
- **CRITICAL**: When adding database/Supabase features, uncomment the Supabase variables in `lib/env-config.ts` and add them to the ENV_VARIABLES array
- **CRITICAL**: Only add environment variables to .env and `lib/env-config.ts` when they are actually required by existing codebase functionality. Do not create placeholder or mock variables.

## Code Quality Standards

### Error Handling
- Always handle database errors appropriately
- Use try-catch blocks for async operations
- Provide meaningful error messages

### Performance
- Use Server Components when possible
- Implement proper data fetching patterns
- Optimize database queries with Prisma
- Leverage Supabase's real-time features when needed

### Dependency Management
- Always verify dependencies exist in `package.json` before importing modules
- Always search on web for implementation details and documentations for third party libraries, never make assumptions

### Development Workflow
- Always verify changes ensure logic is robust, handles all edge cases, and doesn't break existing functionality
- Test builds after significant changes
- Keep running build until build succeeds without any errors